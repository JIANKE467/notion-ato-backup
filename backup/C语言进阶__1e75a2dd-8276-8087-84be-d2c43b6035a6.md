
### 


## 数组

# 数组

1. 当使用scanf给数组输入值时无需取地址符

因为：数组名本身就是一个指向数组首元素的指针，且数组在内存中连续存储


例如：


```c
char password[];
scanf("%s",password);
```


‍


## scanf特性（未完）

# scanf特性（未完）


## 缓冲输入


scanf 使用输入缓冲区来存储输入的数据。当调用 scanf 时，它从缓冲区中读取数据，而不是直接从输入设备读取。


‍


## 阻塞调用


scanf 是一个阻塞函数，这意味着如果输入缓冲区为空，程序将暂停执行，等待用户输入数据。


‍


‍


‍


## 错误处理


当使用`scanf`函数进行输入时，如果输入的字符不符合格式控制符指定的类型，`scanf`的行为将取决于具体的格式控制符和输入情况。以下是一些常见的情况：

1. **整数输入（错误不输入）** ：
    - 如果输入的不是有效的整数（例如，输入了字母或特殊字符），`scanf`将无法解析该输入，并且输入将被留在输入缓冲区中，等待下一次输入调用读取。
2. **浮点数输入（错误不输入）** ：
    - 如果输入的不是有效的浮点数（例如，输入了字母或特殊字符），`scanf`将无法解析该输入，并且输入将被留在输入缓冲区中。
3. **字符输入（对不对都输入）** ：
    - 对于`%c`格式控制符，`scanf`将读取下一个字符，无论它是什么。这意味着即使是不符合预期的字符也会被读取。
4. **字符串输入（遇到空格，空白字符，制表符，换行符停止）** ：
    - 对于`%s`格式控制符，`scanf`将读取直到遇到空白字符（空格、制表符或换行符）为止的字符串。如果输入包含空白字符，`scanf`将停止读取，并将剩余的输入留在缓冲区中。
5. **不匹配的输入**：
    - 如果输入的字符不符合格式控制符指定的类型，`scanf`将返回一个值，表示成功读取的输入项的数量。如果返回值小于预期的输入项数量，表示有输入项未成功读取。
6. **缓冲区中的剩余输入**：
    - 如果`scanf`无法解析输入或只部分解析了输入，未解析的输入将留在输入缓冲区中，可能会影响后续的输入调用。

‍


# scanf读取到空格停止/scanf读取跳过部分字符


scanf() 函数读到空格就停止读取的现象，主要与格式说明符的使用方式有关（例如 %s、%d 等）


 一、基础数据类型控制符


1. %d  %u  %x  %o   


行为：（整数）自动跳过前导空白字符（空格、换行符、制表符），直到遇到非数字字符时停止输入



2. %f  %lf  %e


行为：（浮点）跳过前导空白字符，遇到非数字或指数符号外的字符终止。     


注意：%lf`在scanf中是必需的（与printf不同），否则可能因类型不匹配导致错误



3. %c     


行为：（字符），不跳过任何空白字符，包括空格和换行符。


若需跳过前导空白，需在%c前加空格


 
4. %s  


行为：（字符串）遇到空白字符即终止，并在末尾自动添加空字符`\0`。需确保目标数组足够大以避免溢出

二、高级格式控制符


5. %[]


（扫描集合）


行为：按自定义字符集合匹配输入。


%[a-z]表示仅接收小写字母


%[^\n]表示读取到换行符前所有字符（含空格）   



6. %*


（抑制赋值）


行为：跳过匹配的输入字段，常用于忽略不需要的部分。    



7. 宽度限定符


（如`%5d`）


行为：限制读取的字符数量，防止溢出或截断无效数据。     



8. 长度修饰符


（如`%ld` / `%hd`）


行为：指定数据类型长度。`%ld`读取`long int`，`%hd`读取`short int`。     - **注意**：长度修饰符必须与变量类型严格匹配。
---
 三、特殊场景与陷阱**- **混合输入问题**：    当数值型（如`%d`）与字符型（如`%c`）控制符混合使用时，**残留的换行符可能导致意外读取**。需用`while (getchar() != '\n');`清空缓冲区。
- **非格式字符匹配**：    格式字符串中的非格式字符（如逗号）需与输入严格匹配，否则导致解析失败。    ```c  scanf("Value:%d", &num);  // 输入必须为"Value:123"，否则匹配失败  


## 特性

# 特性


‍


## 结构体（自定义数据类型）

可以理解为能存储多种数据类型的数组（不严谨）


**事实上是创建了一个名为 “struct 结构体名” 的数据类型，因此在重命名时需要带struct**


**结构体不存储数据，数据存储在结构体变量中，所以结构体变量与正常变量的定义和调用无异**


把结构体就当自定义数据类型处理，结构体变量就当该类型的变量处理（别听什么比喻，都会出错）


## 声明：


```c
struct 结构体名
{
成员列表；//存放该结构体的属性（每个下辖变量的属性）
}
变量列表；//变量列表声明改结构体下辖的变量，用逗号隔开
```


![1000016018.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/c3bef86b-135a-4910-8f54-b0d7d805033f/1000016018.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466ZIZWN6BP%2F20260119%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260119T042243Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIAWDMc3%2Fcpwi3CIgG8o%2BBrMNFn4k%2BCMUXQlZcLSwds4DAiEA6sfrvp06qUwExPDfurhmTSZ%2FwQyqLCbc5NPgiId00McqiAQIjf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDE91M3lzO8KkC0uxoircA8soCbdVZyj5f1HCMgNWx7Wvmm%2BlWzUV%2Fqe2%2BUPUKvJw6pXdbmAAgcmCY%2B4%2BRjg0Cz7y8rFGks2eeon%2Fh4cFLlRtUr%2Ft0lJXMbZGOwjqYTLUpNU5oAvFg23nr1EKvIrT0oMnUzvu313UMb9X4o%2FKneAVWqG0fJBGd%2BQPBLcfE5hs8dKLOGqxiQW4N1KvmSshz1lFye8VlQ1kOs9T%2FJoXQFTbGbCRPv4r2Xw2BOZ2%2F9PmDp2eEdlO9AxVGWOZvDe%2B72anUzFbjzmkE%2B5MaFrHempGmuF95Bs%2F6TS3r3XT8jHnOAU7OC1euuSmZXftqPbtfQb7XmLx3jzBFrusbsT%2Fsmz5vgHDeOI1AF6PDmVdAFOXNI2PZOKj%2Bp76KC7Af2FfmwookUFx5LEgtt4zIEjuxsZ8%2BdYy4h8MomFP4%2BT7pa%2FG8kW7inU%2FhCJBKEmeZeD8IMMGtWyM6ayIHLI16QF0N7%2BY83msaqPos9ACryrIYmMWK5agwiN1bxoMGG8Yyrl5DrRhWak182AoDSiQRhmh%2F5Zg%2BKG5S1oXzrcjpaTeZOmF8WUosKW7Dbs86XIr7Lc4iHchk9Ac3ChAo2dWijP70eBxXGyiL231KqEnnHN0UVvgncEd5Q0%2BkI909dR3MMDftssGOqUBELznC4J%2BlRmBHogFHsHw6iMX9EBsx2rNy4pYVFZk5DXCPyBEkt2NXV4GSDqxWqxnvA7tT8799Xj9U%2B8gEhmFU9qVBcMqaVn3SIUwhF%2By3SILDPCynBh1TqTfma%2FZl7pIE530jS9dGxgtPJM9AnnRyr%2B%2FysWYSxd7Efv7J86V0usoFZMSNoINvp8LG3SKhqW2kU1aozfvlvsR4tYeUPS58TVopm7x&X-Amz-Signature=a613ded7bdccf2f6f290b8052eb168c69e9f1aeb86e1640002c716ba54dd8d0c&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


也可以：


先声明好结构体的属性


再声明结构体变量


用这个：


```c
struct 结构体名 变量1，变量2;
```


ps：变量列表不只可以定义变量，还可以定义 指针,数组 等


## 匿名结构体类型


ps：如果没给结构体命名就是“匿名结构体类型”：


后续无法为结构体添加变量（因为该结构体无名字）


## 访问结构体成员


与数组不同，结构体不是通过下标访问的，而是通过变量名.成员名（结构体变量名）访问


例


```c
结构体变量名.成员名=1
```


## 访问结构体


像调用变量一样直接调用变量列表中的变量


## 注意事项


牢记结构体有成员列表和变量列表，


**访问结构体成员用的是变量列表**


**添加结构体变量用的是结构体名**


**如果结构体没有定义变量列表，则需要使用: struct+结构体名 的方式调用**


也可以使用 typedef struct 结构体名 变量名 来重命名该数据类型的类型名（以方便使用），**注意⚠️：typedef并非是添加/修改变量列表**


```c
struct 结构体名{
  成员列表；
}
/*结构体没有定义变量列表*/
struct 结构体名.成员列表
```


## 结构体数组


结构体数组就是由多个相同类型的结构体组成的数组


## for循环

for循环的判断部分省略意味着条件恒成立


## 输入输出缓冲区

# 输入输出缓冲区


有缓冲输入：

1. scanf与getchar从输入缓冲区读取字符

若输入缓冲区无字符则程序暂停等待字符输入

1. 当用户输入字符串并敲下回车后缓冲区也将换行符存入了

scanf读取缓冲区中的哪些字符取决与scanf后的格式控制符


缓冲区中未被scanf读取的部分会继续留在缓冲区中


例子：


```c
char arr[]；
scanf（“%s”，arr）；
```


以上示例表明scanf只会读取字符串


‍


## 清空缓冲区


为了防止缓冲区中未读取的字符干扰程序运行，有时候我们需要清空缓冲区

1. 方法一：使用getchar循环读取直到EOF标识

    ```c
    while ((ch = getchar()) != EOF);
    ```


‍


## 函数参数的传递的问题

PS：


函数间默认数据不互通


传入的参数只是原数据的拷贝


在函数内直接修改的是数据的拷贝


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/47b8f76b-eb35-4c84-9f86-66cd30aafbd7/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4664NNDMZI2%2F20260119%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260119T042244Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCahu7PR1aNIQFc9IWSeduZannzz4dY9KWBgWQ8F0tEDwIhAJ%2FUfcAtA3H05byPWPscYNE4LSwSa%2FkUoMmxm%2B6lXIdSKogECI3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1IgxVYWB8121FfCeczswq3AOb40LvAPsMN90O8Y0p0ts33lHFOERezbYQoPgzL9op7zc8A0sKVUTt5PzYQbXJJVRIHuVZrQaCapa5heC2UWwdTnAVdCn78c6nItDlAUjIhuZpfoXgN3IRo5%2FYDj5VByhG25Rp%2FgKtxBuxMq3UVlXf0jmZlyyXCjMfcAgWMWYt%2FI%2BOAG4JAtbbT4nQnfHAsRd0D3YYRQwmDAavD5LF2x19SFSq0xeq4oaAUThxOwvYrAj24STCG7HWF2qSXB5QfOSmbJS%2BSS0LBXCxdKVXETJeN5%2FjMUBbZwdxDlqJO%2FENaOqaRETGkerpqeOICFa2UiunweM2PzPvHihEDFMl44%2B2Syy5pzNdtIUvIjoSamPjEY3UyU4ZE9S7OSOdpsyZtmCHTky1QQ%2Fy8wjEPTAuUN7ub8mep86w67nkWycminE4Ipa6qWjMY4d%2ByNh8lagPMiSMh%2BK0bAxhCY7UlC3FbHbxAWl%2FseM%2BsHaoIrowmX3HkO%2FCzWIkjjfG51WaLFvOicmdpw%2FW5t%2BNWIskq0afNaE8VxE1%2B9ZDLtqSkN3I6lNHeg%2FdVeHWDxisQiOygrYCiv8Eq0mUuBEGDaQUR53ybb5L%2B5aqVwE7nDCLClO1oK3PEdWjS6UckhntkqXT2TD637bLBjqkAWAeo2KGqLQvjDUCZmYhyR7SM7ZZ7j98vO%2Bd%2BSijlBjrISgNGFloijq%2FqwKRjfEJXBr6Ari9Vx0Czeuqj9j2Vr6dG1M2WP5AhJ2snhUR9ixiZZiUIsVuN1wdOJeJSSyPlMkcbAW%2FdI6jA6G6zwrftC09BqlmbsOzPwclcGE4aKgkDQjb%2BzBRP9EnSbFFNzaDde0rYQNMRM20pxllDAOahZPKytGq&X-Amz-Signature=2a62b6e0bb92a7a26030c3f477a4cc4812f2a073cb914481337b058526e69aff&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


以下是将函数中修改值同步至其他函数的方法


## 函数参数传出方法 


### 1.用返回值传回调用位置（一个值）


```c
return 要回传的变量;
```


这种方法只能回传一个值


### 2.用全局变量


如


```c
#include<stdio.h>
int a;// 定义全局变量a

int hanshu(b)
{
a=b+1;
}

int main()
{
hanshu(3);// hanshu是函数名
printf("%d",a);
return 0;
}
```


定义了全局变量该变量即可在所有函数间互通


### 3.用指针传参


用指针直接在原始变量的地址上操作


要用到：[给指针赋带取地址符（&）的表达式，就是修改指针存储的地址（相当于写入模式）](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2245a2dd8276808c84d2efed69f657b3) [给指针直接赋值，就是修改指针指向元素的值（相当于只读模式）](https://www.notion.so/2245a2dd82768015ab92c5491d573407#2245a2dd827680ce883fc6c3393ee93f) 


步骤：

1. 定义指针
2. 获取原变量地址（在函数外）
3. 

## 指针高级

# 总结的总结


***p有两部分**


**p用来存放地址**


***代表“指过去”**


**&代表取地址，在指针中并非代表取指向的地址，而是指针的地址**


**带*访问的是被指向的元素**


**不带*访问的是地址**


**带&访问的是指针的地址**


#######################################################################################


Q：为什么指针的定义需要定义数据类型


A：对于指向一个已经定义了数据类型的元素来说可能没意义，但对于直接指向某一内存区域来说起到了如何解码（按int解码还是float）的作用


## 指针使用（指针的计算）


### 指针的取内容运算


### 注意事项


*是解引用符


不能直接对一个变量进行解引用，因为该变量不是指针变量（不是“int *”类型）


要先定义一个指针变量，再对要使用的变量取地址，再赋给指针变量


&是取地址符


### 总的来说


指针是一个地址容器


以下是一个用指针修改数据的例子：

1. 初始化一个变量

```c
int a=1;
```

1. 定义一个指针变量

```c
int *p;
```

1. 将变量的地址存入指针（操作指针地址不带*，除非初始化）

```c
p=&a;
```

1. 用指针修改变量值

```c
*p=100;
```

1. 修改完成！

**总结：**


指针用赋值来使用


<u>**给指针赋带取地址符（&）的表达式，就是修改指针存储的地址（相当于写入模式）**</u>


<u>**给指针直接赋值，就是修改指针指向元素的值（相当于只读模式）**</u>


**指针是个容器，要先填充容器（将其他元素的地址赋给指针），再使用**


未存入地址的指针叫空指针（存了一个随机地址）


### 指针的++/－－


指针++：指针的内存地址向后一个单位（并非指针指向的元素+1）（并非移动一个字节）（移动的内存地址<u>**字节数取决于被指向的元素的数据类型**</u>）


指针－－：……向前移动……


```c
p1++；
p2－－；
//p1,p2为指针
```


上面指针不加*因为：[但要调用/修改指针所存的的地址则不带*号](https://www.notion.so/1f15a2dd827680d190efcdc614e6d087#20f5a2dd82768001a131ec778ae7712c) 


### 指针的比较/算术运算


**>,<,==,! = :比较地址谁大谁小还是相等**（同样不带*，因为比较的是地址）


**－，+：+1就是在内存地址加一个单位的字节数（一个单位的字节数取决于所指向的元素的数据类型）**


## 指针类型


ps：除了整形，字符型，浮点型等常见类型外还有指针型，定义指针时用的数据类型就是指针型


### 基本指针类型


New database


## 动态内存分配

<u>_**这些功能基于<stdlib.h>标准库头文件**_</u>


一般的变量（全局变量除外）和运行中产生的**数据会默认放在栈区中**，如果给数组定义空间太大可能会栈溢出，且内存空间大小固定，不灵活


所以可以用动态内存分配，**分配的内存在堆区**


### malloc函数


```c
malloc(字节数);//申请若干字节内存
```


**malloc函数的返回值是内存起始指针，异常返回NULL**（上面只申请了内存但未接收地址）


完整例子（申请后立即存入一个指针中）


```c
int *p;
p=malloc(字节数);
```


### free函数（释放）


释放分配的空间，free函数的参数是要释放内存的首地址


```c
free(地址);
```


### calloc函数(分配并格式化)


calloc函数参数有两个：分配大小，分区个数


calloc将分配的内存区域全写0，并分区


返回值是是起始地址指针，或NULL（失败）


```c
calloc(字节数,分区数);
```


完整例子：


```c
int *p;
p=calloc(字节数,分区数);
```


### realloc函数（修改已分配空间大小）


realloc函数要两个参数：已分配空间首地址，修改后大小


返回值：修改后空间首地址，或NULL（失败）


```c
realloc(首地址,字节数);
```


## 访问申请的内存

1. 直接将以上函数定义在数组的定义中

2.用指针


## 结构体（重构）

**C语言都是先声明后定义**


# 声明部分


### 先声明结构体成员列表


```c
struct 结构体名
{
成员列表；
}；
```


### 或直接初始化


```c
struct 结构体名
{
成员列表；
}变量列表；
```


# 使用部分


### 添加变量列表 方法1:使用结构体名添加变量列表（要带struct）


```c
struct 结构体名 变量名1，变量名2；
```


### 添加变量列表 方法2:使用typedef


### 使用变量名+.访问成员列表


```c
变量名.成员名
```


如


```c
printf(＂%d\n＂,变量名.成员名)
```


## 动态内存管理

## malloc（开辟自定义个字节的内存空间）


malloc的返回值是指针


**malloc需要强制类型转换成要存储的数据的类型（需要转换成指针型，如int*，float*，用int则malloc的返回值会丢失指针的属性）**


用法：


将malloc赋给一个指针


```c
数据类型*指针变量名=（数据类型*）malloc（字节大小）
```

