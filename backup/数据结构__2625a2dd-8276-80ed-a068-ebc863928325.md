
数据结构就是


对数据的增，删，改，查


我们讨论的数据结构的问题一般都是指在没有硬件虚拟化的机器上（如连续内存空间和不连续内存空间）


## 1.1时间复杂度

### 时间复杂度


由于不同机器性能不同，无法相互比较，因此，时间复杂度是以程序循环的次数为度量的


PS：时间复杂度度量的是逻辑次数，而非指令次数，所以只计量循环次数


时间复杂度是一个式子


$$
F（N）=.....
$$


F(N)是时间复杂度


N是执行次数


如：


$$
F（N）=N^2+2N+10
$$


### 时间复杂度估算（时间复杂度渐进表示）（大O表示法）


将对式子影响最大的一项留下，剩下部分去掉，就是时间复杂度的渐进表示：


用O（N）表示


基于上个例子：时间复杂度渐进表示为


$$
O（N^2）
$$


PS：时间复杂度渐进表示有大O表示法，大Ω表示法，大Θ表示法，这里只讨论大O表示法↓


规则：

1. 只保留最高阶

例：


$$
T(n)=n^2+5n+7 \quad \Rightarrow \quad O(n^2)
$$

1. 忽略系数  [常数是变量不能忽略，如  T(N) =kN ]

例：


$$
T(n)=10n^3 \quad \Rightarrow \quad O(n^3)
$$

1. 如果只有常数（如循环100次），直接常数改成1

例：


$$
F（100）→O（1）
$$


PS：如果有m次的和n次的两个循环，顺序执行则↓


不知道m，n大小关系：则全部保留         


$$
O（m+n）
$$


m＞n：则只保留m


$$
O（m）
$$


m＜n：则只保留n


$$
O（n）
$$


PS：时间复杂度有：最好，平均，最坏


一般取最坏的时间复杂度作为程序时间复杂度


### 冒泡排序的时间复杂度


冒泡排序：从头开始两两相比，如果前比后大则交换


最坏情况：倒序排成正序


循环次数：（n-1）+（n-2）+……+1


时间复杂度：（等差数列求和公式）


$$
F(n)=\frac{n*(n-1)}{2}
$$


渐进表示：（n乘进去分数拆开）


$$
O=n^2
$$


注意⚠️：时间复杂度不能只看循环次数，要看算法逻辑（循环次数不一定是固定的）


## 二章：线性表

## 1.1顺序表

顺序表在逻辑内存上是连续的（未虚拟化的内存），但在物理上不一定是连续的


顺序表就是数组，它要求数据连续


## 顺序表的实现——静态分配


    使用静态数组（固定大小的数组）叫静态分配


    ### 定义顺序表本体部分


    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #define MAX_SIZE 100 // 定义顺序表大小
    typedef struct {
       int data[MAX_SIZE]; // 用数组存数据
       int length; // 顺序表当前长度
    } SeqList;
    ```


    **代码解释：**


    Q：第四行typedef struct是什么意思？其后的SeqList还是结构体变量吗？


    **A：typedef struct与最后的SeqList意思是将这个未命名的结构体重命名成SeqList。**


    **与正常结构体不同，此时的结构体后跟的并非成员列表，而是别名，所以此时的SeqList不是结构体变量。**


    **推荐使用的标识符：**


    MAX_SIZE：顺序表（数组）最大容量，单位不是字节，与顺序表定义的数据类型有关，如int就是4字节一组


    lenth：顺序表当前容量


    推荐将数组和已用容量打包成结构体（便于维护），再将结构体名重命名为SeqList


    Sq是顺序的缩写，List是表


    **Q &A：**


    Q: 顺序表就是数组，为什么还要先构建结构体，再在结构体成员中定义数组？


    A. 可以直接用数组（存储数据）+一个变量（记录存了多少数据）。但在做顺序表调用的实现时需要修改两个元素，带来两个问题：

    1. 代码量一大，人就看不懂，一个数组+一个变量，是干嘛的
    2. 其他实现方式也可以，但这是标准做法

    PS：到了这里是顺序表仅仅是定义了还未声明，需要在主函数中声明，也就是只定义了结构体名，没有定义结构体变量列表，需要在主函数中定义结构体变量名。


    ### 初始化顺序表（函数）

    - 需要将length变量（顺序表长度）赋为0
    - 需要将数组中的每个元素赋值为0（内存中有脏数据）（用一个for循环实现）

    ```c
    void InitList (SeqList){
      for (int i=0; i<MaxSize; i++)
        L.data=0;
      L.length=0;
    }
    ```


    ### 主函数


    ```c
    int main(){
      SeqList L; //声明一个顺序表
      InitList(L); //初始化顺序表
      //...后续操作
      return 0;
    }
    ```


## 顺序表的实现——动态分配


    ### 定义顺序表本体部分


    定义一个指针（用于指向表的首元素）


    定义一个变量length（用于指示表的当前长度）


    定义一个变量MaxSize（用于指示表的最大容量）


    ```c
    #include<stdlib.h> //malloc函数的头文件
    #define InitSize 10
    typedef struct{
      ElemType *data;
      int MaxSize;
      int length;
    } SeqList;
    ```


    ### 初始化表（函数）


    用malloc动态申请空间（malloc返回的指针要强制转换为与要存储数据一致的类型）


    给最大容量赋值为InitSize（InitSize在前面定义为常量）


    给当前长度赋0


    **PS：malloc函数=数组（所以动态分配中没见到数组）**


    ```c
    voud InitList(SeqList &L){
      //用malloc申请一片空间
      L.data=(int*)malloc (InitSize*sizeof (int));
      L.length=0;
      L.MaxSize=InitSize;
    }
    ```


    ### 在实现一个表扩容(函数)


    传参：顺序表，增加的长度len


    定义一个指针，将 L.data赋给该指针（表起始位置指针）


    用malloc重新申请一片比原来大的空间,赋值给L.data


    用for循环将原表p中的数据移过去L.data


    修改变量MaxSize（最大容量）


    调用free函数将原空间释放


    ```c
    void IncreaseSize(SeqList &L,int len){
      int *p=L.data;
      L.data=(int *)malloc ((L.MaxSize+len)*size of (int));
      for (int i=0;i<L.length;i++){
        L.data[i]=p[i]; //用数组的方式调用
      }
      L.MaxSize=L.MaxSize+len;
      free (p);
    }
    ```


    PS：也可以使用realloc代替这个函数的功能，但推荐使用上面介绍的实现方法


    PS：为什么L.data [i] = p [i] 用数组的调用方法？同样的问题，为什么动态分配结构体内没有数组？


    因为在初始化函数中，**malloc相当于申请了一个数组（事实上是连续内存空间，这块空间可以当数组使用）**，所以这里使用数组的调用，结构体中也不用数组。


# 顺序表的特点


**随机访问**：因为是按顺序存储，可以在O（1）[循环次数为确定常数] 时间复杂度找到任意元素


**存储密度高**：每个节点只存储数据，不存储指针


**扩容不方便：**扩容需要复制一遍，时间复杂度高


**插入删除不便：**插入删除需要移动大量数据


## 1.2顺序表的插入/删除

PS：本节以静态分配为例


### 顺序表插入函数


    传入参数：i（插入位置），顺序表，e（插入元素）


    **验证逻辑↓**


    用if验证i（插入位置）合法性（0～lenth+1），不合法则return一个值（表示i不合法）


    用if验证lenth>=MaxSize，成立则返回一个值（表示空间不足）


    **主逻辑↓**


    用一个for循环让表的元素从lenth（当前长度）处依次后移一位，直到i（插入位置）停止


    插入元素e


    lenth（当前长度）加1


    return一个值（表示插入成功）


    ```c
    bool ListInsert(SqList &L,int i,int e){
      //插入位置合法判断
      if(i<1||i>L.length+1)
        return false;
      //顺序表是否已满判断
      if(L.length>=MaxSize)
        return false;
      //将第i个元素及之后的元素后移
      for (int j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];
      //在i处插入元素e
      L.data[i-1]=e;
      //长度加1
      L.length++;
      return true;
    }
    ```


### 顺序表删除函数


    传入参数：i（删除位置），顺序表，e（返回删除的元素）


    **验证逻辑↓**
    用if验证i（插入位置）合法性（0～lenth+1），不合法则return一个值（表示i不合法）


    **主逻辑↓**


    将要删除的元素赋给e


    用for循环实现i后的元素依次前移


    lenth减1


    返回值（表示成功）


    ```c
    bool ListDelete(SqList &L,int i,int &e){
      //判断i的范围是否有效
      if(i<1l |i>L.length) 
        return false;
      //将被删除的元素赋值给e
      e=L.data[i-1]; 
      //将第i个位置后的元素前移L
      for(int j=i;j<L.length;j++)
        L.data[j-1]=L.data[j]; 
      //线性表长度减1
      L.length--; 
      return true;
    }
    ```


    注意⚠️：


    函数的参数只能传入，对于传入的参数的修改不能直接生效，需要通过return来返回（因为传入的参数实际上是原参数的副本），或通过传入引用符号+原参数 来实现修改后立即生效


## 1.3顺序表查找

# 按位查找


    ### 静态分配


        查找第i位的值


        （以静态数组顺序表为例）


        直接调用结构体，成员，数组下标即可（可以加逻辑判断i位是否合法）


        ```c
        ElemType GetElem(Sqlist L,int i)
        {
        return L.data[i-1];
        }
        ```


    ### 动态分配


        同样可以用结构体，成员，数组下标的方式访问


        动态分配中malloc≈数组，它通过其前面的数据类型规定了数组一个元素空间大小，通过后面的值规定了数组长度


        **因此malloc与数组访问方式相同（通过下标访问）（要将数组名替换为malloc首元素指针）**


        ```c
        ElemType GetElem(SeqList L, int i){
          return L.data[i-1];
        }
        ```


    ### 时间复杂度


    O（1）


# 按值查找


    查找有关键字的元素


    用一个自增的for循环嵌套一个if判断，当：关键字==数组元素 时，return这个值的下标


    ```c
    int Loc ateElem(SeqList L,int e){
      for(int i=0;icL. Length；i++)
        if(L.data[i]==e)
          return i+1;
      return 0;
    }
    ```


    PS：


    这个代码有一个问题：


    如果数组中有多个相同的值，只能查找出第一个值


    ### 时间复杂度


    最好：循环1次：O（1）


    最坏：循环n次：O（n）


    平均：O（n）


    注意⚠️：位序=下标+1


线性表用公式表示为


n为表长


$$
L=（a_1，a_2....a_n）
$$


### 线性表的基本操作

1. 初始化表 lnitList(&L)：构造空线性表，分配内存空间。
2. 销毁操作 DestroyList(&L)：释放线性表L的内存空间
3. Listlnsert（&L，i，e）：插入操作，在表L的i位置插入e
4. ListDelete（&L，i，&e）：删除操作，删除表L的i位置的值并用e返回删除元素的值
5. LocateElem（L，e）：按值查找，在表L中找e
6. GetElem（L，i）：按位查找，在表L中找i位置的值

**其他常用操作**

1. Length（L）：求表长，返回线性表长度
2. PrintList（L）：输出操作，输出线性表L中的所有值
3. Empty（L）：空操作，若L为空表返回true，否则返回false

## 2.1单链表定义

与顺序表区别：顺序表每个结点只存数据，链表每个节点不仅有数据还有下一个节点的地址


单链表指单向链接，只能从头到尾访问


单链表不支持随机访问


![1000000679.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/993a0bcc-3015-4547-90e7-c47158817d40/1000000679.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466UUDFW44Q%2F20251215%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251215T041047Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHwaCXVzLXdlc3QtMiJHMEUCIQCXphtLhf8BsV6saJuexU6VFSLuyWeTaVF9KYhgRmFikAIgSRS5eNB0jzxGhStQCbpkPkociKLF2qIqt%2FnUF0lZyaEq%2FwMIRRAAGgw2Mzc0MjMxODM4MDUiDIIQhzsbDWFMBRqZMCrcA9zyUzXuDFb%2FGZlc4Gilew6vVaOzE76nsfqqbR1JrWnZ3LvXN%2Fw3ZuVp2zmEqh%2BvKGnBaG4SP68LA3%2FW8Ydig7nHOl1q0uj1qnb6wu0aESTAriRzvIg%2FEdZDlutORuzN9vOQ6WBVrCzHWotow5%2BkAaFgH7KW4BADIjqbkDxqiJ%2FqnlHeGfn7muoMEf8X%2B7EjgMbI2%2FxdpxUcUyUVeaphXF1qYpA2JD3kBQRRMogmKXkfa8%2FhgMQHyf%2FNkTOY5WAOQUD%2FmxHrVZVOEY3QxFi7QHh6BSkciDnyKao3CWVF1Ns1zSJQGplBeV0VUJRVT%2BvsOIbknFnr8t953CkCDHGIouoaOKz7i8Dz0%2Fyfm4u3fSEHBAg%2FHCBXXamcbtTc%2B0OH6eYAkifrgytblWJO4L6sQRDEqUlx6xeHdEaEIc8spj54QWXGcqHgo%2FDR22yje8Y1TzfH28AGAPxzPLCGvMy57FDsqh7%2BlZ85bSxe6Eyp5k2CYvNDxcivmD6Eas%2FWvdrjM2K7%2F4uygaZb1qq4FFqaNPpXP3oQx%2FJKn7rlYR7cnKT%2FpLmkLyVioD5%2FOFitN6lTmiMfv%2FpQZoCBFaHrA0KWK5GB7ecyCHbYGvdn03jIg1VpLi3WBNe108EzVsbwMPiL%2FskGOqUBpG5N8HVJ%2BNZYcJaUSJ27J5FZP8vUt6iHv%2FYIY3%2B8Tz%2BsssDFA2VBGv5XIfiSlWzTv6gFrB8tehQgOEfw4DRMSzAIeowO2rC0C95u6Pp8kpB%2BVLW8OVMSbCBObkzzcTkvcWDWB1xO0KKFZtTEpLXCGTH%2BTCV8diaurF8UNs%2B5PdR5BS1w8dLykWIYO4TCLeva499sVzAQvfCew5307cZX23YG3kdt&X-Amz-Signature=801f274f3bf2f80afe51d5e43174e57729caf697f5482b92d59f7d6802bd3b0b&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


### 定义


定义一个结构体LNode，有两个成员：

1. 某类型的变量（数据域，用来存放数据）
2. 下一节点的指针（指针域）（声明一个为该结构体所表示的数据类型的指针，指针名为next）

```c
struct LNode{
  ElemType data;
  struct LNode *next;
  };
```


### 重命名struct LNode


用typedef


```c
typedef struct LNode LNode* 
typedef struct LNode LinkList
```


这两个等价，只是为了提高可读性


强调这是一个单链表用LinkList


强调这是一个节点用LNode*（这个*只是为了说明该节点是一个指针，不加不影响什么）


### 初始化单链表函数（不带头节点）


初始化空单链表：给头节点赋值为空


```c
bool InitList(LinkList &L){
  L = NULL;
  return true;
  }
```


PS：

1. 将头节点设为NULL是为了防止内存中有脏数据
2. **使用LinkList & L（引用L），而非LinkList L（直接传入L），是因为直接传入L修改的是L的副本**

**还可以加一个判断逻辑，判断头节点是否为空：（空表判断）**


```c
bool Empty(LinkList L){
  if (L==NULL)
    return true;
  else
    return false;
}
```


### 初始化单链表函数（带头节点）(多数）


用malloc分配一个头节点给L（结构体声明返回的是一个指针，L就是该指针）


判断是否分配成功L是否为NULL


将第一个节点的指针域设为NULL


```c
bool InitList(LinkList &L){
  L=(LNode*) malloc (sizeof(LNode));
  if (L==NULL)
    return false;
  L->next =NULL;
  return true;
}
```


**还可以增加一个判断逻辑，看指针域是否为空：（空表判断）**


```c
bool Empty(LinkList L){
  if (L->next==NULL)
    return true;
  else
    return false;
}
```


[link_to_page](https://www.notion.so/2785a2dd-8276-80c6-868b-c08137a685df)


### 总结：


带头结点空表判断：头节点指针域为空


不带头节点空表判断：头节点的指针为空


## 2.2单链表插入删除

# 按位序插入


在第i个位置插入指定元素e


### 带头节点（头节点不存数据）（函数如下）


1.找出要插入的位置的上一个节点的地址


方法：定义一个结构体变量*p用来表示第i-1个节点的地址


先将结构体变量*p初始化到头节点（第0个节点）上，然后通过循环不断将*p修改到下一个节点的指针上，直到到达第i-1个节点（该循环需要一个节点号计数器j，用来指示循环到了第几个节点）


2.使用malloc申请一个新节点*s


3.将新节点s的数据域赋值为e（插入内容），将新节点s指针域赋值为p（上一节点）的指针域，将p节点（上一结点）的指针域修改为新节点的指针（不是指针域）


### 不带头节点（函数如下）


除了插入第一个节点操作不同，其他与带头节点的函数相同：


因此用分支判断插入第几个节点


第一个节点：


malloc申请新节点*s


新节点s的数据域赋值为e（插入内容），新节点s指针域赋值为p（上一节点）的指针域，将p节点（上一结点）的指针域修改为新节点的指针（不是指针域）


另一分支注意将*p初始化为第一个节点（不是头节点）


# 前插入


# 删除


## 重构

重构分两个部分


1.定义（实现原理）：各种大类要包括分出来的小类。如：线性表要知道下属类别：顺序表和其下属类别：顺序表插入/静态分配

> 注重实现方法，代码用文字描述
> 每个最小页面内用函数分类，一个函数写一块，写出总结：将什么几个功能写成几个个函数？**画一个层级图**

2.实现（实现代码）

> 注重代码，用链接链接到1，写出代码，同样一个函数写一块

```plain text
数据结构
│
├── 一、绪论
│     ├── 数据结构三要素
│     │     ├ 数据的逻辑结构
│     │     ├ 数据的存储结构
│     │     └ 数据的运算
│     ├── 四种逻辑结构
│     │     ├ 集合
│     │     ├ 线性结构
│     │     ├ 树形结构
│     │     └ 图结构
│     └── 常用时间复杂度
│           ├O(1)  
│           ├O(n)
│           ├O(n log n)
│           └O(n²)
│
├── 二、线性表  ★重点
│     ├ 顺序表
│     ├ 链表
│     │     ├ 单链表
│     │     ├ 双链表
│     │     └ 循环链表
│     ├ 基本操作
│     │     ├ 插入（移动/指针）
│     │     ├ 删除
│     │     └ 查找
│     └ 与链表比较（时间/空间/效率）
│
├── 三、栈与队列 ★高频
│     ├ 栈（后进先出）
│     │     ├ 入栈/出栈
│     │     └ 表达式求值
│     ├ 队列（先进先出）
│     └ 循环队列（判空判满）
│
├── 四、串（了解）
│     ├ BF匹配
│     ├ KMP
│     │     └ next数组
│     └ 模式匹配复杂度
│
├── 五、树与二叉树 ★大题区
│     ├ 二叉树概念
│     │     ├ 满
│     │     ├ 完全
│     │     └ 性质
│     ├ 遍历
│     │     ├ 先
│     │     ├ 中
│     │     ├ 后
│     │     └ 层次
│     ├ 二叉排序树
│     └ 平衡树AVL
│
├── 六、图  ★难点
│     ├ 邻接矩阵
│     ├ 邻接表
│     ├ DFS
│     ├ BFS
│     ├ 最小生成树
│     │     ├ Prim
│     │     └ Kruskal
│     └ 最短路径
│           ├ Dijkstra
│           └ Floyd
│
├── 七、查找
│     ├ 顺序查找
│     ├ 折半查找
│     ├ 二叉排序树
│     ├ AVL树
│     ├ 哈希表
│     │     └ 冲突处理：链地址/开放地址
│
└── 八、排序 ★考得最多
      ├ 内部排序
      │   ├ 冒泡
      │   ├ 选择
      │   ├ 插入
      │   ├ 快排
      │   ├ 归并
      │   └ 堆排
      ├ 时间复杂度
      └ 稳定性
```


## 线性表

## 顺序表

# 描述


    顺序表是一种线性数据结构,它使用一组连续的内存空间来存储数据元素。在顺序表中,元素按照逻辑顺序依次存放,每个元素的位置由其下标(索引)确定。这种存储方式使得顺序表可以实现快速的随机访问,时间复杂度为O(1)。


    **顺序表 = 用一段连续的内存顺序存放数据的线性表。**


    ![1000022845.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/4d4c34a1-b22d-4315-be4b-6780d9650784/1000022845.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4666G6I3AEC%2F20251215%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251215T041049Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHwaCXVzLXdlc3QtMiJHMEUCIQCiTT9r1srBB3L%2F9Nxt2QFQrto1ZzqXsB2jdXn%2BF4RS0gIgbfrPqe%2BYvuax5ZHyFe3m6OJX1d9gTekWA%2F3ie5vtJSoq%2FwMIRRAAGgw2Mzc0MjMxODM4MDUiDHJDt6PTD0T%2Bm%2FQ8NCrcAyoD%2BHGbwu1OnR5Cr9LoZ7A36xWGBPOiY4t%2BKkvc5lU7oW7ID0LcPbOaDCzIM%2FrNU2p%2FcJttvZ1XksR1TFSQiHcUqJAQJ8xomVSQazYdepUjbA9wQJ97lKq7w%2BMMajXqm4vbtJCgG4v%2F1oRooDFxfTB%2F8oOLPVy%2BEy1TQUKTnS7OLlUeGVfrxSnwMICGWjf9WUwESe5VlxJqRd1gBBkWyjXfidU%2FIvVisNKtkLKN%2F%2FS8Y6pgwLw9a9LuDT3W6DmL%2BtC9SgoPz0gRQ6hIDgD1Y2MlqRXyZ7Tp2T4x1IS1apLU0ssDirb4tSeB8kgbGtmVAS0h%2B8yj%2F9DtQ9hrznev1MtpMSKLkr1MVoqairXq8IdvhBdizq%2FROz6QsXreFm71N0iyX5avlPal2jcUT98C8Mrm%2BuGUUB%2BoCvEmLALTTnV7kTuJELVbrtyhceybkESZZ2r7qMRaxQmQHcYhRFZb8jLDjpAz%2BhJ5okpqpYtnzIK5fo3yr8Pfo3msReDUyJA8ko1AK%2FcFitTIR7akbLa9rRS1d96iedVV77%2FMZ04hiaLEF8KPTkRZrahWUpFoA0JUWy1lcHD48T2mtCIwQiPCq0QstVShqz5qjduhw%2BXgP9PGr04WoCtXrFKsK932MICM%2FskGOqUB0fMsgGwy83%2BGPmjSvnbfNk3vj6HLyGFprzQDeqQ5yUSxTl3bSN7%2BrUJG5qUqDEDyNI4Hy%2Fn7YoozINggbTQfYseQSMBMhYI%2FEk8bBLMDFXC8Bw1NkSrBdyK%2BiPkjnu%2F4ItEtO7ziixBlyvTHcIYym9CiL%2BJbzS%2BXnCASNszp1NEJSV868nIbxAb0tDiSaxrYRhaw9%2FU14CmWrTAtUbapj74fZ0H5&X-Amz-Signature=88a73cbe36a9f22a4868c96add1b8e0a177d663853c63730dd2dea113f30f10f&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


    （以上图为内存结构）


# 内存特点


连续的内存


# 节点结构


只有数据


# 特点

    - **随机访问效率高:**可以通过下标直接访问任意元素,时间复杂度为O(1)
    - **存储密度高:**不需要额外的空间存储元素之间的逻辑关系
    - **插入删除效率低:**在中间位置插入或删除元素时,需要移动其后面大量元素,时间复杂度为O(n)
    - **空间固定:**需要预先分配固定大小的连续内存空间,可能造成空间浪费或溢出
    - **内存连续**

# 顺序表有两类


    ## 静态分配的顺序表


    **用数组实现**，长度固定


    ## 动态分配的顺序表


    **用malloc函数申请内存空间，用指针访问，修改，删除，添加，**长度可扩展


# 适用场景


频繁读取/修改


不经常插入删除（慢）


## 单链表

# 描述


单链表由一系列节点组成,每个节点包含数据域和指向下一个节点的指针域。链表中的节点在内存中不必连续存储,通过指针将各个节点串联起来。


![1000022847.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/c32cf9a2-961e-4c2e-8dcb-cb0a1f6f8313/1000022847.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466WNJN5JUZ%2F20251215%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251215T041050Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHwaCXVzLXdlc3QtMiJIMEYCIQCkVazfW6iPXVmyQHX49eTpD7l4CYzYnBw56h2BUYBdagIhAP7hGLxl25rS9EBVEFn%2BuhU3eK2wbnVnBUs6GNjFhUsqKv8DCEUQABoMNjM3NDIzMTgzODA1IgzoG6Rf3%2Fd3y0bani8q3AMIviNmjJNVqRPRg8LZXvaWKnCouLm2eZ7oyvCLk3dZXE7VlVwoW5lwCFmGsNfAdAJzibBJSdqa832WzkS%2Ffsyaz1ewu3iLTdEwOwpn4vLeQmJu80X49fSdC21BfR1vUYiw%2BEGYI%2B0O6nWmae5fDpjx5nAp3XL%2BQHEpSGtTYNqJopX%2B8yg3ohPgw9CVGYwWd%2FESEZCg%2F9nWtI7TAjPyyANAfk%2FaOnu8c%2Flgm%2FevD%2B7shgnz5FcI3o6iiufORaG4cUHNhZqEBY1CKtLuHUA%2BPkYsJQWFUdpeAkTnpmCkg9q37BOj5blE%2FdFJ0DcL6%2Bd84pC2TVjTXQG5BvC43Nx9t23gYu93sLQ44EZCD8a39n%2Fj6626uAshHlEG1TyZwrQKZk5YABjTd%2BQwqWZHcqRI9uUjaqBSo%2B20uugar%2FpRvycRpSDbDy9aDKN2PLDDNaqkBjYwGxhNEA6%2FvW1WVMk9wf5fqjD4z5POj4nrTVqt%2FujCCjgu13LffKtJC8aPp3eAz6xpdtdOmeZvL99mHV2Juy1S2kJl3LQnTe1ULD2gdLiWEWWH69CZVRGAFpeTN0bM52z61H4LQMeAMTpeQRiXv9v5VXiTyyqAFUqpVk2bLY6zBR2qEZSWZoHBzN4MLjDUi%2F7JBjqkAXm6vWMCo9oAp70%2BCw0lnDXMk7HoMiyPHS3Y8%2F%2B9AB%2B%2BaJufwlRbsKmIn4m5%2FhTCnTMTrlbyjG5UDRYQdJVUTay8btua0WJm3OABUs1c1YYN9SYduVjGcO4mpbHbPna0ggxRMbShQ5jq89knLOG%2FHCE8kFlITksSXqM1GqkloE7IeNRfHAb%2F02k8PeHHstozBBym5Eel598S6HSaR1W7MTW79zoB&X-Amz-Signature=b9358d29cbd8e29637a834c78841a03300e8aa50778268f7d97e042633b1ac13&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


（以上图为内存结构）


# 内存特点


不连续的内存


# 节点结构


数据+下一个节点的指针


# 特点

- **无需连续内存**: 链表的大小可以动态调整,无需预先分配固定的内存空间
- **插入删除高效**: 插入删除只需要修改指针
- **访问效率低**: 不支持随机访问,查找特定元素需要从头节点开始遍历,时间复杂度为O(n)
- 只能单向查找

# 分类


### 按有无头节点分：


**带头节点的单链表**


带头节点的单链表在链表的开始位置增加了一个不存储有效数据的头节点,头节点的指针域指向第一个实际存储数据的节点。


**好处**：

- 第一个节点不需要特殊处理

**不带头结点的单链表**


不带头节点的单链表直接从第一个存储有效数据的节点开始,没有额外的头节点。


**坏处**：

- 修改第一个节点需要修改整个链表的指针（整个链表的指针就是指向第一个节点的指针）

### 按循环与否分：


**循环单链表**


循环单链表的最后一个节点的指针域不指向NULL,而是指向头节点(或第一个节点),形成一个环形结构。这样可以从任意节点出发遍历整个链表。


**非循环单链表**


非循环单链表的最后一个节点的指针域指向NULL,表示链表的结束。这是最常见的单链表形式。


## 双链表

# 描述


双链表每个节点包含三个部分:数据域、指向前一个节点的指针和指向后一个节点的指针。与单链表相比,双链表可以双向遍历,既能向前访问也能向后访问。


![1000022959.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/fbd430d3-d204-4691-9d1a-98cb381e5713/1000022959.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466RF4V75PS%2F20251215%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251215T041050Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHwaCXVzLXdlc3QtMiJHMEUCIFetFXqOVcx6E7HTSzftZLxdSZrGmbOjEbrmiUTKH866AiEA3CqSaetefi1tfi5vuOh8ed%2FsgHxnlQwwhNO%2BvLTtc5Qq%2FwMIRRAAGgw2Mzc0MjMxODM4MDUiDE6o7yQfBy9sfTd4RircA5oqqND32ME7DC64kqxi7PPuH4%2BxU%2FwdhUojRjEtUdDj7105PUuY9IyWjMbBqxP0IT23rc4wvIh%2BRQj4cIH0YRB%2F26h0hDo%2BTRPxmfmKRnJ9lK8MaI8bOLEfkPA2f%2BXSChkibITKhlLvwjo%2FBahoDe%2BxZkywMnUHgYACVHDy3e4ClkSvoDKerovnvcQyMgP1p3gmbcQfB19EpGitDqu4dqgJiJsXXVCt0xz%2BEm%2Fvlawl6oJ8zV0%2Fbr7wRLUmPGOOx0tuzxtTrAd3QQo9NfQvVTlipgBZa7QdSaRscwXfw5%2F6dQA0bpQpPxGOqmLHf2PGTegRLLeo9yd%2FaIEHasDL2A5blaQPr5Ppmz5qehWQ%2B2E%2BwA1%2FTRkqbKZlBT%2Fynv4%2BruWJMJtoCSYgT4vvq5h2qYa%2BNtX09i0CLRf8nqTif9hsrroPiX6bJOk9LSZWr8sSM5Q%2FVe1i63Fm%2B867ih4mg4Fs3b8N4zpwVugouhwwQPZlADTUl1%2BtXiZSJ8Dc08WipWACMVzI6aqIYcl%2BUv%2Fo5CS6AFadOlMZd3EtWzg2yVPhhutsSuwWbFi08duz9qwxim6h1cU1YrCrqf6AqiD1n5RDyxZLf7kxLgtocfss90h%2FLwiGVOAnQpp9CPTlMLuM%2FskGOqUBehWL%2FVCccIoYqdFdB%2F62x1JR8ifgDBvcfBnXejkwFXuwNTi7hCwTaJUxwqGhkDaXd5ypi%2F9aa%2FWmD29pEIeJFh26bAXv3YcGzPSoZz9kQuLJy2pX%2BnTP9M%2FDUfZ2UG6nWxMdmrHqz2r%2B9Go4TxT%2FZ2LxD2KnI8y8e1bBFSQTjJMvuQLBWO3Q8OAZ7zH%2FXRzJpNLUj9N3ouVz65cbJZE7LRfrfEDA&X-Amz-Signature=621c3ae41146a31bf5ac33fcac43cc54562a545085c270851e986ca7513d0967&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


不连续的内存


# 节点结构


上一个节点指针 + 数据 + 下一个节点指针


# 特点

- 可以双向遍历,提高了查找效率
- 在已知某个结点的情况下，删除该结点不需要遍历找到其前驱，插入结点时，能直接同时调整前后指针
- 占用更多内存空间,因为每个节点需要两个指针域

# 分类


按循环与否分：

- 循环双链表:首尾相连,头节点的前驱指向尾节点,尾节点的后继指向头节点
- 非循环双链表:头节点的前驱和尾节点的后继均为空指针

按有无头节点分：

- 带头节点的双链表:有一个不存储有效数据的头节点,便于统一处理插入和删除操作
- 不带头节点的双链表:第一个节点即存储有效数据,操作时需要特殊处理边界情况

## 循环链表

# 介绍


循环链表最后一个节点的指针域指向链表的第一个节点,形成一个环形结构。与普通单链表相比,循环单链表没有明确的"结束"标志,可以从任意节点出发遍历整个链表。


![1000022960.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/d2324c7f-99fa-47eb-9d93-3d4cb14ed9f4/1000022960.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46676575IFV%2F20251215%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251215T041050Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHwaCXVzLXdlc3QtMiJGMEQCIGhjJP%2FHzySP%2BkrJbo9UpUnbFJvQL%2F%2BozLpYHABGV2R5AiBMUYPr9Oe%2FuHdY4jySMxBRb11Vb0aZggwsHQzk5mPhxir%2FAwhFEAAaDDYzNzQyMzE4MzgwNSIM18dGkRMySQKijEfWKtwD9stZ1C2R2dCAqF%2Bco4zQJmS3bkjNHhPI393V0H%2BzYPuihvxf8XWs65pe%2FvNsnp5LvRBEk8oYQx6CEbup5225R1bQUo5oozx3o0f%2FfmetOFltX%2FiW9bnT2xyKrN%2FIxUuM1p%2BLSTkJVhZ%2FVbHe4mIYPBA4d70yWeN6i2%2BEDSyprS%2FEDsV5wLDCAfUkkTlaBMkBdFE9AJVOFFzHYPDKGh42kKdLB6zoJN6fWKmk64pPkuB2g2KQfhYebNbqpAWbFrcKIuT0JqfTPOhI4v97Q1gNYLT4PZknVsvkBUqNRrsKIq2P3jGMSNQTFiLCKfwYbFeh0shP%2FXVMtsOgivQU47rsii9uTO2LpQMdIcbOWp7ox%2BiYqUcUZiWVipMbuwppqibPFUNx0QTDxwG1fqaUovGYiLsR8K8kofJZLF%2FPm2AdeHXqY%2FmcJQZiXDrdfgs0FMjs3pI5NTS68ees8Cammt8fSVqDTKKZb9yPCPGO50cwlSHIqOsQoEPXsx8zhwfs4wGuxXeS1RQovZnrpS4CarWpLOXgkUTQTqxAyOyaRMU%2Frpu9kOLMr7y0DP%2F3sswdr%2Fke%2BCASu89RHw1NZoxDxGDVDdTuwc690WJ6rpTBiqrnMy%2F%2BFU6RiuuJw%2B33gu4wtoz%2ByQY6pgG9XVaFKtk%2FR0r%2BIeQ8n4bThF001WKdxuEBGKXywpnZWJ5gelMFueLZ7HAGAQcSPYh8kVe42DgkZDbLT9qvH3CRnCyDaLkVn5WHXP7Fl671eeJaQmt4GsDZo61dRjNGmyUtZLTHj%2FW1EGdrlCBsw%2FRlW0r%2BEpLp%2BQR%2BHR4o7Z4V%2BMHk2exuCkfYisnsMM%2FIOzpxzHiMQlyjrR4jEAkG30jAmy666GKS&X-Amz-Signature=01bee4409a921acb3ef2bc269f34ad4b018dd6ad2cf7d55e73b284b55f4c83dd&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定，循环的静态链表是连续内存，循环的单/双链表内存不连续


# 节点结构


视情况而定如果是循环单链表与单链表一致，如果是循环双链表与双链表一致


# 特点

- **无明确尾节点**:最后一个节点指向头节点
- **可从任意节点遍历整个链表**
- **空表和非空表判定方式不同**：空循环链表：头指针为空，或头结点的 next 指向自身（视实现而定）

# 分类


按有无头节点分：


根据是否使用头节点,循环单链表可以分为以下两种实现方式:

- **带头节点的循环单链表**:设置一个不存储数据的头节点,头节点的 next 指向第一个数据节点,最后一个节点的 next 指向头节点
- **不带头节点的循环单链表**:头指针直接指向第一个数据节点,最后一个节点的 next 指向第一个数据节点

按单双链表分：

- **循环单链表**:每个节点只有一个指针域,指向下一个节点,最后一个节点指向第一个节点
- **循环双链表**:每个节点有两个指针域(前驱和后继),可以双向遍历,首尾节点相互连接形成环

## 静态链表

# 介绍


静态链表是用数组来描述的链表结构,它把数组元素分为两个部分:数据域和游标域。数据域用来存储数据元素,游标域用来存储下一个元素的数组下标,从而模拟链表中的指针功能。这种数据结构在一些不支持指针的编程语言中特别有用,同时也便于实现内存的统一管理。


![1000022961.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/6715167f-1db2-46b8-aa67-4cc9c7ef07df/1000022961.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4667KBBOEPK%2F20251215%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251215T041051Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHwaCXVzLXdlc3QtMiJHMEUCIAoQV3tqZuI%2FKG3e87mywbGEbZlH5L%2FK9DgNbMVpKn9aAiEApnHTLxHpYeVwDW8jB4kkjIVTle1VSvmDllbHTZPucJYq%2FwMIRRAAGgw2Mzc0MjMxODM4MDUiDJVvfbCPbtZ0%2BHEEYCrcA7P2B3sDY8MtDs%2FUXkyWPASUJEaS%2BpWnx1Bh3DuvvTu3HY%2BkcW6hpDOMHUZtXSB48GVMQHd47gtScJVxYS%2BSZxRpa5noVCQrtfA0u5im4AK47MSNSeX8%2B%2BK3CvAMtNQ8bmYEJOTuR7i32JTMm5eTclp3YUXqLVlk7OECNZ6nab%2FsbbmqagwTgY7tJmcBufbLZw%2BLw4hfqsLZPyIgRkDYAjxandcphM%2B%2FiKCh0fbo03RkdXOTl%2Fnyu0gdXRxbA1UXY%2FVsdb7TsLyTNdMmYC6iWX%2FiutpcdWX5G6TIxYrrfu6Xc87aKdgtYBx2Vc6SwUIWwk4Yzwqllw%2ByUMC2km49DlThgI%2FATbTUU4WUyrD4%2BoWlAlEytwGN1I%2BXnLpvpC376l4id1elKj754hM1Ll3BPTlkiD4VaskeCQ7U%2Fb5SpF4VzGlmCGFrOV%2FG6RBBEv7tz3b7EeMb2sfkyt%2FBiyiBw%2BqiUwGCNfQgl9Nu%2Bqe4zr0d4Mj%2BhymorIQJSroMjI2gJ2IgiOeWuO9FxI88umWfprlmayjnXYSaGQBtTOA7yBWX11gf7q%2BLLsWbhhOOrfayqPWRME2cwIhHcumkIGPdH7bu%2Frml38d0h%2FNBXQjwwddoxZ1M5pIRDbclXDeiMKCM%2FskGOqUBGlyS%2BzfRM5o3F%2FDhKcoNe%2Bqerlt%2FnJsYJdKuzpn%2BwZJByZhFQyIelGl0%2BzA11T9AJby9jLPYMF9h8p80Jj4x%2BDzwh9doAMR5%2FkfFcm822DTGjnAlqQ7DI1zGKOXtjzTlvucAEf6RAiDzW2EhBtxk2AhtYM9Ua%2FRHjqPvl2V92QecyPru4m%2BG%2BQ6be9gmhBB6JEkozUnkzqO0BlpOLHFS5osxxUFQ&X-Amz-Signature=3223b7fb701f04648f2f8856ba383db874e5240bc529dd6b8d4cbef54c03a062&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


PS：静态链表与其他链表不同，需要申请连续的内存空间


PS：静态链表与顺序表的区别：


顺序表按顺序存储（直接使用数组），


静态链表虽然使用连续内存空间，但不按顺序存储（用数组+游标模拟指针）


# 内存特点


连续内存


# 节点结构


数据+游标（游标记录了下一个节点的数组下标）


要点：


如：静态链表的游标顺序：2-15613；数组第4个数是头节点


代表按照：数组第四个→第六个→第三个→第五个→第一个→第二个  的顺序访问


PS：**一般规定第一个节点（也就是数组下标为0）的节点为头节点，最后一个节点的游标为-1**


# 特点

- 使用数组实现,需要预先分配固定大小的存储空间
- 通过游标(cur)来模拟指针,实现元素之间的逻辑链接
- 插入和删除操作不需要移动大量元素,只需修改游标值

# 分类


## 按存储方式分类

- 单链静态链表:每个节点只包含一个游标,指向下一个节点
- 双链静态链表:每个节点包含两个游标,分别指向前驱和后继节点

## 按功能分类

- 备用链表:用于管理空闲节点,便于动态分配和回收
- 数据链表:实际存储数据的链表结构

## 按是否循环分

- 循环静态链表:最后一个节点的游标指向头节点,形成环形结构
- 非循环静态链表:最后一个节点的游标为-1,表示链表结束

# 备用链表


使用静态数组：数组申请的空间是固定的，在插入等一系列操作完，会留下剩余未使用空间，将这些空间的下标组成一个静态链表，当需要插入一个节点时可以直接通过备用链表找到空闲位置


PS：没有备用链表就只能遍历

