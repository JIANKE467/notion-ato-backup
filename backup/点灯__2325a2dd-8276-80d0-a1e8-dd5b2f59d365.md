
# 点灯1

1. 看原理图看灯对应哪个寄存器
2. 操作寄存器（1高电平0低电平）

寄存器标号是个标识符


### 实现代码


```c
#include<对应MCU型号的头文件>
void main()
{
  P2=0xFE;
  /*P2是寄存器标识符，各型号不同详见
    原理图和相应头文件
}
```


其中寄存器标识符可以接收10，8，16，2进制，格式如下：


10进制：直接数字


8进制：0开头，后接8进制数


16进制：0x开头，后接16进制数


2进制：0b或0B开头，后接2进制数


### 注意事项

1. 如果发现灯亮灭状态与代码状态是补码（灯与代码亮灭状态相反），说明是“共阳接法”（灯是反着接的）代码反一下就行

      与之相反的叫“共阴接法”

1. 如果灯的方向顺序与代码逻辑顺序反了，且根据原理图检查代码没有错误，有可能是原理图与实际电路板走线不一致

    （严谨的厂家不会犯这种错误，普中51 
      单片机A2原理图就是错的）

1. 编译器报错“未定义的标识符”：寄存器标号填错（注意区分大小写）

# 点灯2（按下亮松开灭）


ps：操作寄存器单个位的方法：看头文件，使用P2_0等标识符


ps：寄存器不仅能写还能读


### 方法


用分支语句处理：如果寄存器 P1_0为1（高电平）给 P2_0赋值1，否则为0


### 注意⚠️

1. 由于单片机的程序不会退出（循环运行），所以一定要有“否则（else）”不然灯亮起来就不熄灭了（如果用循环语句来控制，在循环结束要有关灯的语句）
2. 按键按下和弹起会有抖动（通常是20毫秒），所以程序中要“消抖”（看需求，并非必须），消抖方法就是让程序延时20毫秒

# 点灯3（松开时切换灯亮灭）


### 按键松开检测（阻塞执行）


**标准按键弹起检测逻辑：****（用循环检测按键是否持续按下，而非是否弹起）**


![1000017450.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/4beb1ce2-56c4-4db8-b66c-e7f7a2793e0d/1000017450.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466WBI2MRHR%2F20251209%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251209T035926Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDV86yBmRhw5CP8s6b5DMQnZx%2BAQ%2BEltmGLUYzljB1MzQIgJlXg6aT8oDmeKMWe%2B2eMmAM%2F4pgTFgHzzPoehWUIS1AqiAQItf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDBgeXfJEQxzY0PkRfCrcA5DQD68vwFT1jHOwi7%2F6nPBNN%2F7MEqyuMJvoHXUqMRCOzYA4uRY%2F747j3hOb5qMy6a%2B2E01lo7zJNHVGO47vldZwSVtcOmmElEsjHNkzPH%2FDxc%2FaI73vtg2wh9XLPXn4d8sjoV8r9U6nUMcP%2FNdoD957lk%2B9tXenT8zOccGn%2Be7eWZQtBdvG3NrB1zg4AjMJbbLMxeKzclbPMvFIYnEzYDYMnMxY6cuddyRrUQF7eN%2B4Opnay5TOT8RWLSLNmgXujbk41SkVLU6HGdHgEG%2FcpvdlqFogl6up%2FDhkonYmCWGifqSFVVsyxQrihFdfCXuw3glTsMI8kQoISuotbCEJG0ANBN1ynGal2qD5OKTBQiII4Q%2B5vXT2FtgzLjlvgeI1PQ9AvRJ0aMo29L%2Fdl19ldxVS8mz4aPI2ExTHfb5QOK0R9Rrqq3XU5ZuWv1UmzVP3OOMkdl3c6Y7hy0I%2FpkpzhsZR8SkDKiwcJs0WUZvsLbwQnZS%2F3XDAD8AW2kzUD0CzBUNKzNaOK%2BtDShz7tbejq3nzlNHFAukjIwgYuPIomXyw2EEpfaEYBO3%2BKmUffvh5VNWdxlJpjgAQ5EIiUnelyKs%2BKPxt02sCiBcIdaR7oKSZ5mtywZVIwg3cgRdGMJy33skGOqUBjbnVEQAxSwM%2BZZYjjUBeKgyYarasIm1QFDwmNYONvy%2Bbso8%2FlG4HCvW5I6Gy%2Fkctxkb%2BiOb%2Bu308sLtRrpG9kO348laJK24T2LrTYlGoFZ78ds9sEuT1W2HrSng5Zl9pNntrwxrNKhsULF2BKIqMw5jYNTdULeMZpqaDiUEfrHsOVaApc1qkAPnnOXoXYfsxK0%2FY6azwRoZoH2fBm7ezg6dSLXCW&X-Amz-Signature=07d55ac334e51a50d900f960c1a72c98f406e5ff1f085f1540a8211ac53065dd&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


检测逻辑：按下检测   用if   ——   按下状态是否持续  用  while（按下后的寄存器状态）+空循环体  如果为否就会退出循环 —— 按钮松开执行的语句


<u>**通用逻辑：持续状态检查用循环实现**</u>，


                     **单次状态检测用分支**「<u>**一个程序周期（复位→运行→复位）只做一次判断的用分支」**</u>


**注意⚠️：**

1. **松开检测在逻辑上必须先判断是否按下，否则就成了”按钮未按下检测“**
2. **与正常逻辑不同，松开检测是：按下检测，持续按下一直循环（松开跳出循环），松开执行语句**
3. **总结2就是不要检测“按钮松开”，而是相反，检测一直按下**

### 按键消抖


误区：按键消抖并非是按键是否按下的持续检测，只是屏蔽了第一个高/低电平后几毫秒的电平变化


消抖代码一般在被触发的代码后面


# 按一下亮再按一下灭


开灯和关灯可以直接赋值


<u>切换亮灭状态则用取反运算符</u>


# 点灯4（二进制显示，每按一次+1）


# 点灯5（按钮1灯左移，按钮2灯右移）


核心：


使用位移运算符


移位到头后的循环处理

