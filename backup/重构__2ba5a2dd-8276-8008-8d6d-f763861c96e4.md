
重构分两个部分


1.定义（实现原理）：各种大类要包括分出来的小类。如：线性表要知道下属类别：顺序表和其下属类别：顺序表插入/静态分配

> 注重实现方法，代码用文字描述
> 每个最小页面内用函数分类，一个函数写一块，写出总结：将什么几个功能写成几个个函数？**画一个层级图**

2.实现（实现代码）

> 注重代码，用链接链接到1，写出代码，同样一个函数写一块

```plain text
数据结构
│
├── 一、绪论
│     ├── 数据结构三要素
│     │     ├ 数据的逻辑结构
│     │     ├ 数据的存储结构
│     │     └ 数据的运算
│     ├── 四种逻辑结构
│     │     ├ 集合
│     │     ├ 线性结构
│     │     ├ 树形结构
│     │     └ 图结构
│     └── 常用时间复杂度
│           ├O(1)  
│           ├O(n)
│           ├O(n log n)
│           └O(n²)
│
├── 二、线性表  ★重点
│     ├ 顺序表
│     ├ 链表
│     │     ├ 单链表
│     │     ├ 双链表
│     │     └ 循环链表
│     ├ 基本操作
│     │     ├ 插入（移动/指针）
│     │     ├ 删除
│     │     └ 查找
│     └ 与链表比较（时间/空间/效率）
│
├── 三、栈与队列 ★高频
│     ├ 栈（后进先出）
│     │     ├ 入栈/出栈
│     │     └ 表达式求值
│     ├ 队列（先进先出）
│     └ 循环队列（判空判满）
│
├── 四、串（了解）
│     ├ BF匹配
│     ├ KMP
│     │     └ next数组
│     └ 模式匹配复杂度
│
├── 五、树与二叉树 ★大题区
│     ├ 二叉树概念
│     │     ├ 满
│     │     ├ 完全
│     │     └ 性质
│     ├ 遍历
│     │     ├ 先
│     │     ├ 中
│     │     ├ 后
│     │     └ 层次
│     ├ 二叉排序树
│     └ 平衡树AVL
│
├── 六、图  ★难点
│     ├ 邻接矩阵
│     ├ 邻接表
│     ├ DFS
│     ├ BFS
│     ├ 最小生成树
│     │     ├ Prim
│     │     └ Kruskal
│     └ 最短路径
│           ├ Dijkstra
│           └ Floyd
│
├── 七、查找
│     ├ 顺序查找
│     ├ 折半查找
│     ├ 二叉排序树
│     ├ AVL树
│     ├ 哈希表
│     │     └ 冲突处理：链地址/开放地址
│
└── 八、排序 ★考得最多
      ├ 内部排序
      │   ├ 冒泡
      │   ├ 选择
      │   ├ 插入
      │   ├ 快排
      │   ├ 归并
      │   └ 堆排
      ├ 时间复杂度
      └ 稳定性
```


## 线性表

## 顺序表

# 描述


    顺序表是一种线性数据结构,它使用一组连续的内存空间来存储数据元素。在顺序表中,元素按照逻辑顺序依次存放,每个元素的位置由其下标(索引)确定。这种存储方式使得顺序表可以实现快速的随机访问,时间复杂度为O(1)。


    **顺序表 = 用一段连续的内存顺序存放数据的线性表。**


    ![1000022845.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/4d4c34a1-b22d-4315-be4b-6780d9650784/1000022845.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466XTT2RPCD%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041354Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIC%2B8DWpkwlI0pC8nUMUmGb7BjEmcKJC9UXiUlLBYR1DjAiBBq9B76l4cvBUEcQIfBPLc4WGSw9iS7pGQKWkJzxsERir%2FAwh6EAAaDDYzNzQyMzE4MzgwNSIMy9Bye4IIneFB1PijKtwD8Adg64MeLeWx7N4PuOREUsbMkSb35fx6zxUDoIVrG1St%2FupEa7hAMKoF9XYNdG2%2Bhn3lYCagyMjlF3mpADlWiOtDUtIaKy5VM3BS7GTbZe97aSPf2PnyIDejkjCZ4HezbyxGB2xxWG%2F3jb%2FRcG4P%2FT7xSkK4ejqAeYA6yAeJhD6OVmmHX9kqP0qVBoVvEZMjLKR%2Bwxr59MMdQjX7WJN2%2BC5wfm0BCsfG1tOw1cH9RZMDAHy1o%2FKHO%2FYfig1odenojyTrd4qY2eZuy94MfNFxKLkzSiDmMvNPuWEQ9xzGjWKlqmr4u7efoqLneIZmp%2B4AVHxyuy0mmz%2B5J2qnOyIP1P8jAQSwFVJb31t7Ibr%2FyEKDBxbO28byiNgL%2FRabWu4qIhp509ulsscxOLBLBbG7o15wSBV7530V8NiyuIDdcAa50%2FefIh28o8Af3zxJwEGDRHb3yr9acZml2jWjGvjLklTk92xYhImHCyWrKZOsWkQ4hYSR%2BuYlToVEMi6PrH6vOCKYnCElS%2B02pj4bMZNjRlTn90BfXAaxT1Lp5oJWzJVS3ipenA9M7Gk7ukTNK0DyEn26wWpWRsnOU0pRII9F7EBB%2Beisf7mLyVnU4oR2pqD2DY6571TlvDey6AIwq4rCygY6pgHoYB6mqG3F%2BsR7yf4oczgulqEUdmCNsd%2BJAN1e2jop%2F6GYmu%2B%2FfO0MR5f0h1S8yN0HT5rhDLdoXcp5FvfwQg5y1IsU9QQAarD8UNTDY%2FuHoRxy1NityQNKthb4AukTUrA%2FMkZ1OvBL3G1A0zyxxdR0KPqUO1MdmAiZB4QVk%2B0uxTLDSxM4LyUO1GGtuaSCmjtJUJ%2FqPPwvX0bL525oN36AbWCJTYwE&X-Amz-Signature=7b7510a108cbd0bfa74755dade4689c824c2f545133f12562545d4b782981309&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


    （以上图为内存结构）


# 内存特点


连续的内存


# 节点结构


只有数据


# 特点

    - **随机访问效率高:**可以通过下标直接访问任意元素,时间复杂度为O(1)
    - **存储密度高:**不需要额外的空间存储元素之间的逻辑关系
    - **插入删除效率低:**在中间位置插入或删除元素时,需要移动其后面大量元素,时间复杂度为O(n)
    - **空间固定:**需要预先分配固定大小的连续内存空间,可能造成空间浪费或溢出
    - **内存连续**

# 顺序表有两类


    ## 静态分配的顺序表


    **用数组实现**，长度固定


    ## 动态分配的顺序表


    **用malloc函数申请内存空间，用指针访问，修改，删除，添加，**长度可扩展


# 适用场景


频繁读取/修改


不经常插入删除（慢）


## 定义+初始化

## 顺序表的实现——静态分配


    使用静态数组（固定大小的数组）叫静态分配


    ### 定义顺序表结构（结构体）


    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #define MAX_SIZE 100 // 定义顺序表大小
    typedef struct {
       int data[MAX_SIZE]; // 用数组存数据
       int length; // 顺序表当前长度
    } SeqList;
    ```


    **速记：**


    **用结构体打包一个数组（存数据），一个变量（存顺序表当前长度）**


    ### 初始化顺序表（函数）

    - 需要将length变量（顺序表长度）赋为0
    - 需要将数组中的每个元素赋值为0（内存中有脏数据）（用一个for循环实现）

    ```c
    void InitList (SeqList){
      for (int i=0; i<MaxSize; i++)
        L.data=0;
      L.length=0;
    }
    ```


    速记：


    这是一个函数，执行：遍历数组并赋0，记录顺序表长度的变量赋0。


    ### 主函数


    ```c
    int main(){
      SeqList L; //声明一个顺序表
      InitList(L); //初始化顺序表
      //...后续操作
      return 0;
    }
    ```


## 单链表

# 描述


单链表由一系列节点组成,每个节点包含数据域和指向下一个节点的指针域。链表中的节点在内存中不必连续存储,通过指针将各个节点串联起来。


![1000022847.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/c32cf9a2-961e-4c2e-8dcb-cb0a1f6f8313/1000022847.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662E4GLXWA%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041355Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDreFy8zQ6FaS8p7%2FEyfYldYiJPg2dLvtPe4PcFKDNf7wIhAMlPgqT%2F0odpe9r%2BS2AGrxBVCKt4JWLZGfWv%2FxhbCVQuKv8DCHoQABoMNjM3NDIzMTgzODA1IgwfCc9v8nCBIzTmjc8q3AMlmSRIS5l71cK3fcORf%2BzXdMuJ9B1MnuDvyFP0Xi6sZ%2FCnANv2vOOa8K%2F365fTdUhXSx3F7RpKJpQUq91HfdPiBTh%2B4XnbBtnaoYWgrlMBHW1yda%2Fvg%2B5fgjEs9aPcgOZdwCyVImisRpCNmZ5LgJtwVzl649Vs8pbqusGV5hWU4DdIEiXFBxAY4EITf%2BqXPEjc2QNP%2BfN1kAcffKpSE0QAE1vJIDY1HrCAsQgqSiAP%2BUne8Pj8uj1NjAdphwgkyVfnk2Y2dKlh0x0XwJVqeNEzmIKwM8%2B4KVfxBbWfAIeLwbBvH7JpDgEUxSL2doiy3n7ir6XbMYRISSuuejD17DESDVUW9IP4a%2Bdlnx%2FxRyZXT3gKdSY8JhWMg4FNLHHrbfwP5XhrznkY2JpDAnSXyv%2FNG9HnfMXqXrl6pwoCdQKRtwOSF6vz5xgcT1KLq8O5KclvfMPTbNcucoWz%2F3PVrDiB3tE%2ByFVq5udlVTJemVliPkXP63mv4bvOK%2BsjMcr3%2FX6g%2BgP7JXsNzfhV4J0OHk6HcN7x8haDHFoJ23com7sENgGr%2BU7PS4UQ3CxxKlHilV6NLPQmhcgW%2F1BygxASH53x2FOL%2FVEtvCV4E1mwDx%2FM%2Bzxt%2FkNZwcMxGmFXrjCYisLKBjqkAc2Hg%2Fvwb3rVkF2vUtVtIUzLY8Oo8a0jjCyPZtvWTUe3dX5qpf1BATyLWROxHtLHmndNDmKE91TVHFOfGgsf2hzz11Cq4R1cK2QbKCEAcyMm5rEekocqINmwzH%2FJEG2NVpBDURk76mDOcHLhU1B2unWDvrXkcfypHNIoobe79UGZT7fbmtF1e%2F5PGQ7bulDeXeGbrv8KENU3ijPcEgJuD5uMGjRc&X-Amz-Signature=ec717d3ad60177244d2ee47178f9b96f7093d5f71100a66a661dd0280865fc95&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


（以上图为内存结构）


# 内存特点


不连续的内存


# 节点结构


数据+下一个节点的指针


# 特点

- **无需连续内存**: 链表的大小可以动态调整,无需预先分配固定的内存空间
- **插入删除高效**: 插入删除只需要修改指针
- **访问效率低**: 不支持随机访问,查找特定元素需要从头节点开始遍历,时间复杂度为O(n)
- 只能单向查找

# 分类


### 按有无头节点分：


**带头节点的单链表**


带头节点的单链表在链表的开始位置增加了一个不存储有效数据的头节点,头节点的指针域指向第一个实际存储数据的节点。


**好处**：

- 第一个节点不需要特殊处理

**不带头结点的单链表**


不带头节点的单链表直接从第一个存储有效数据的节点开始,没有额外的头节点。


**坏处**：

- 修改第一个节点需要修改整个链表的指针（整个链表的指针就是指向第一个节点的指针）

### 按循环与否分：


**循环单链表**


循环单链表的最后一个节点的指针域不指向NULL,而是指向头节点(或第一个节点),形成一个环形结构。这样可以从任意节点出发遍历整个链表。


**非循环单链表**


非循环单链表的最后一个节点的指针域指向NULL,表示链表的结束。这是最常见的单链表形式。


## 双链表

# 描述


双链表每个节点包含三个部分:数据域、指向前一个节点的指针和指向后一个节点的指针。与单链表相比,双链表可以双向遍历,既能向前访问也能向后访问。


![1000022959.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/fbd430d3-d204-4691-9d1a-98cb381e5713/1000022959.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466TXYBR3SK%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041355Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIDm8sMau6a9Uok0hNw1ZQBBuuP5QtKWG1ui78SfULlnKAiAtKLjrUbcNI4s6GOeDQ9rLvDalV7vs0K68Zen7MkDQCir%2FAwh6EAAaDDYzNzQyMzE4MzgwNSIMjvI5rV3pr4dqLOp9KtwDGQ2POoB9Vpv%2BXrqGLfD%2BiG8d4fLqPIiE12r%2FSaO5fnz7czyfImMPwCfYqMiqaEUHqykyOa63ILHj4Ng72aP3tiJjCgp3OnxDkbUiIhNyhWj0%2B3HJ%2BXCCzfWVhwDH%2BidZLEijoH53FxC8PXoR1xQHCRrSgN3jPy4qa2ss%2Bz05e%2BdNsV%2FHloXCUJU7%2B%2FFezfdQzXQHdfDqlZudVRj1yEaIty4JCsjYXRuhd4XZEQ5dD8Xb9W%2F734oxikpN%2F22a%2Fe8gwrszGmExDvA0B6CZLYBXW2%2F9sNrggeMlsNAcDYMTfHmeQ4v0tXHeCgGfb5F6M94OrHy8BkLnAq1LYgeHt2PNo%2FMjRafjOblTCvW4Hw4wl4l%2FU0ueoLgVU4vXwlJCgOlbn0NajBzQO18DxV%2Bd6R8EjTSgNScw7G9pwVRIz8GZELRZWTD6pcE1OBQmAzvsRFpoeVFIecjRvq9lUBSraMBoa9gOwuaQHpvvhuKsEL7g%2BqvblcE2CIwiP9uYv2Jq9%2FfMgPK14qHJj1AkyjQuLLAHJLbBczRBNA5e6yVzYZG7eSRZ7MJR1NgHcrq8Vzm499uOruLitc4zZIARDbNjwoU3eidblnMsjpDaoDNhl6gLUu37jovnHFUSCZCHgSUwlorCygY6pgEqXmU0iHKm%2B0rPMndtbCiBM8NXqe3RknZ3aZ0wgBaV2cQwgot19cScta5I64IAjhCtJ%2F7IK1f1icRzSjZFb0cjNO%2FgyKMwa6%2FKmoj8Z6DHApCYLa1vZV%2FjeOYYSfd8ZxyAvg4H%2Fe3Xuf%2BVGfgxUzJCmGt7LX19g1naCmJez5kXEECcPRBuoFuqJrHQE6OfQo952kvQGio4eILjs46zOqnW4lht%2BoXj&X-Amz-Signature=1c5d088e8362f055144a76320096e0aaa55c73bc31de89316977b78548056919&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


不连续的内存


# 节点结构


上一个节点指针 + 数据 + 下一个节点指针


# 特点

- 可以双向遍历,提高了查找效率
- 在已知某个结点的情况下，删除该结点不需要遍历找到其前驱，插入结点时，能直接同时调整前后指针
- 占用更多内存空间,因为每个节点需要两个指针域

# 分类


按循环与否分：

- 循环双链表:首尾相连,头节点的前驱指向尾节点,尾节点的后继指向头节点
- 非循环双链表:头节点的前驱和尾节点的后继均为空指针

按有无头节点分：

- 带头节点的双链表:有一个不存储有效数据的头节点,便于统一处理插入和删除操作
- 不带头节点的双链表:第一个节点即存储有效数据,操作时需要特殊处理边界情况

## 循环链表

# 介绍


循环链表最后一个节点的指针域指向链表的第一个节点,形成一个环形结构。与普通单链表相比,循环单链表没有明确的"结束"标志,可以从任意节点出发遍历整个链表。


![1000022960.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/d2324c7f-99fa-47eb-9d93-3d4cb14ed9f4/1000022960.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466UPR3FCKP%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041355Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIDlKl3AcJp1%2F3OSQrJHL5irjQPP9rKnrQjY0fpNnH6EfAiAUD%2B7OOlXcBxJN9TdfjzC6nGTWO1d4N1bP3E72iJ5NcCr%2FAwh6EAAaDDYzNzQyMzE4MzgwNSIM4%2BABUNAsJKFOk%2BtoKtwDj8NzQN7ceC6rFTv2AXw9oDVPW2ARUbfitqeQvW0Ny5u4gIExZXb0JcoedhXxz9bToFKwLM9CPfhHdjTESKlTueFT3GIKlVOn55So7aSusRs50HFFyW1QkqsdBkRMAzN1QE7fyI5ySlaK1TK673zlh1nxhwNdiZsI2DnNhsGnXBFyOXy8omIFXk9aAvgb4EF0s%2FV0gdjkEC5BC%2FfjZOmTI5rDivhsZs7waRuJ3Uyh8Sj1bWKTMF2jH%2FBs9mlmFdX%2FwNbAYUqN9pDtmgDkRepKYjoN81YYZ4xGFSPV6N%2B%2BFOR%2F%2BLzsSYVHJHYaHfqZoH8isLWnK8LguBQl0yu0FD%2BiCOyZvgeXmtjEAFI9AQ2kjcqPh6Ccdd4KgAXjJ8Qm%2F8NvS7Q8TnPAWJSTAlQWg8G8%2B%2B5qmkkPhvLRBltQqDXeAimZxPHlAzTNqsIPELUcfDX52K%2B6O0JPQh9X55m1Ft41AFj3Vr9vi%2FaYShy8R5BRqda6CSLMoglqcUpR6BHHjPEAfBZXzJmeIRSJFeD1bKJMuSfNiGXt%2BzljRU3bT5QZKHNdAhng7tV4cSs3BdhnGtlftUs%2Fpn27sfzP%2FOKjh1j%2FYKUDqC6jZDQPvHBtqgn3qWcvRk%2FK%2FxeJj8oRni8wtYrCygY6pgHN5YpsR%2BL0%2FEmkhPVgwC62pcxXWqHOyXPDJwqH6PVGF97iyNYEIhtnMRcaqlHnZUnSEWmh%2Bw5z9IKmxuxxINnyxCZX23EYrRszTADcddvLcpm4qKArLfY6ZIEdv1d9%2BQWMY9HqzY9uoQAnfYvcFqFv3laO0kVjGXOXlWsLQceF1%2FIZryAgvaz3YPW7VcTE379fVt91kgHqpPG%2BIdneSmDTMzYT1cIu&X-Amz-Signature=76c9b161420a0d78c7eb799426838f0f6c34f079636f66e86916f1b89c2a901f&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定，循环的静态链表是连续内存，循环的单/双链表内存不连续


# 节点结构


视情况而定如果是循环单链表与单链表一致，如果是循环双链表与双链表一致


# 特点

- **无明确尾节点**:最后一个节点指向头节点
- **可从任意节点遍历整个链表**
- **空表和非空表判定方式不同**：空循环链表：头指针为空，或头结点的 next 指向自身（视实现而定）

# 分类


按有无头节点分：


根据是否使用头节点,循环单链表可以分为以下两种实现方式:

- **带头节点的循环单链表**:设置一个不存储数据的头节点,头节点的 next 指向第一个数据节点,最后一个节点的 next 指向头节点
- **不带头节点的循环单链表**:头指针直接指向第一个数据节点,最后一个节点的 next 指向第一个数据节点

按单双链表分：

- **循环单链表**:每个节点只有一个指针域,指向下一个节点,最后一个节点指向第一个节点
- **循环双链表**:每个节点有两个指针域(前驱和后继),可以双向遍历,首尾节点相互连接形成环

## 静态链表

# 介绍


静态链表是用数组来描述的链表结构,它把数组元素分为两个部分:数据域和游标域。数据域用来存储数据元素,游标域用来存储下一个元素的数组下标,从而模拟链表中的指针功能。这种数据结构在一些不支持指针的编程语言中特别有用,同时也便于实现内存的统一管理。


![1000022961.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/6715167f-1db2-46b8-aa67-4cc9c7ef07df/1000022961.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4663XVCHUNU%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041356Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDOxQGLM8P4Ux3t9onOT2WUPGXrPIyq64PWAiIpSkYYHQIhALmTuMoY7Bt8EulvXA0ym42I2mf6tOd3%2BzqrIMjJMGK4Kv8DCHoQABoMNjM3NDIzMTgzODA1Igwbq20malGOPZwJQ9cq3APDYGcrTl%2FrIEtE%2Fo0KzLfVXfWuNxgJTbuI1RVLjALaKciiVSX%2FCtyOpnbfoINY0hrPpL3U6CX33Gflp3HGJpIP94kDOW42C5uiZaN3WiKwoD1BvjCuNekvMw6R%2FwaZ4bv%2BoSbrsPzxC4ZhlGDv7FdTScDXVDV7ccXuTrGusjIs5bOnwdYwwUneckeJkBMsn7R95q0%2BJixINsDYvGkkdMKZxXL7W6ZD24mHWQtpRUZL%2BIMPtURUSsgij7PeBM5JXx2g8n1nTp7i8wTPkrK7CulWU1XzOu%2BIQFDSqluL9tnf6KcwfQGT1Ei6gVziGPG7TnRBee7nlgvjwqk5LkfxljMtwG4gPMPYYRRovIw%2BVv%2FhMzgvG%2FRyMn%2FYYomyUK8%2B8VBS937QBriuejS0mp7QC7D2x%2F%2B68Ptje%2Fk7%2BExH22MN%2FIC%2FyGDNU7Ig5rmjKg3UvIflnxTK8FLcxxNPjC8AhfJ3I47MJDLKclYIRd%2Fi2QWtC44JrS57wEzhpOyBqz9UKn085zpVhlCA6CHQoSWrZI%2Bc3iFSDt%2BQUAap2X6MJeWu5lfZUk4F33LBUKpaROedZGGIwYelaXmymAzTXdK6um6QHovMXGzWqce2cL00Kj5kgROgH3Z6Ba8F%2FjEd%2BzCLisLKBjqkATggzIuwxD4l0eG6GvbLsOKe5pGto9M%2F7KuwdSmKGz9XC8NXLyLAA%2F1jhIe3vAz2958AAjQt0%2BmzfSXe%2FJ3razhYz9i0wvZO%2BeEujRKaCwa2u8P6TDd6d1xv6szMq1Rbd2M%2B5x3pLRZzoBp6%2FK6E8WJ0ljCo%2Bw%2BFPa5JHuG8l0afoNjcG2nuOpYNc9irsAwEb0ibqGoBU%2FN2OoRLkkuG0WJSSpGm&X-Amz-Signature=5201fd25781916849308fc0474cbd209ad2fa0c2ec96ede961a93287d1d29e01&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


PS：静态链表与其他链表不同，需要申请连续的内存空间


PS：静态链表与顺序表的区别：


顺序表按顺序存储（直接使用数组），


静态链表虽然使用连续内存空间，但不按顺序存储（用数组+游标模拟指针）


# 内存特点


连续内存


# 节点结构


数据+游标（游标记录了下一个节点的数组下标）


要点：


如：静态链表的游标顺序：2-15613；数组第4个数是头节点


代表按照：数组第四个→第六个→第三个→第五个→第一个→第二个  的顺序访问


PS：**一般规定第一个节点（也就是数组下标为0）的节点为头节点，最后一个节点的游标为-1**


# 特点

- 使用数组实现,需要预先分配固定大小的存储空间
- 通过游标(cur)来模拟指针,实现元素之间的逻辑链接
- 插入和删除操作不需要移动大量元素,只需修改游标值

# 分类


## 按存储方式分类

- 单链静态链表:每个节点只包含一个游标,指向下一个节点
- 双链静态链表:每个节点包含两个游标,分别指向前驱和后继节点

## 按功能分类

- 备用链表:用于管理空闲节点,便于动态分配和回收
- 数据链表:实际存储数据的链表结构

## 按是否循环分

- 循环静态链表:最后一个节点的游标指向头节点,形成环形结构
- 非循环静态链表:最后一个节点的游标为-1,表示链表结束

# 备用链表


使用静态数组：数组申请的空间是固定的，在插入等一系列操作完，会留下剩余未使用空间，将这些空间的下标组成一个静态链表，当需要插入一个节点时可以直接通过备用链表找到空闲位置


PS：没有备用链表就只能遍历


没看：


初始化，销毁，插入，删除，按值查找，按位查找


求表长，输出操作，判空


## 栈与队列

## 栈

# 介绍


栈(Stack)是一种遵循后进先出(LIFO, Last In First Out)原则的线性数据结构。它就像一摞盘子,只能从顶部添加或移除元素。


只允许在一端插入/删除/修改


![1000022962.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/f159f114-04b2-4fa4-b54e-096d4e1300d6/1000022962.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466T6RRLST4%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041357Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELL%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIBa159LNf6sByRl3bKpC1uKrdWVYUmkytnvdJ1%2FSs4QMAiBAaGDnSMfGopRYzgW1KZlYEqDsE97rnRgyTwX%2Bhor9UCr%2FAwh6EAAaDDYzNzQyMzE4MzgwNSIMpiijNuy4R2SExEvMKtwDLUk%2FSzr7dpggHG68cYa9MdpaMlxyWhpI2VOV84OdxMCveeIToM6nrOAX3NOmwluW%2FQuLBfZlblHrl%2BbndtBZv1rjuyR0jLFfR86N5xexTyt7ftZQYnFMWOCBK88LRgu0Arwgnvx%2BvTau7L0K43pTZsjGN0bAA4s5lpo%2BN4Hf%2FFyqazIXaxFAorzrF1r6tdjH8kR7sK5FV2pLbxd4ckPAwHdHCV7Pc7piTzusteJ%2FNUanVrE8EoeS6ivVZeT2DJ3f8z7NymuW1g17UEQ%2FWKUESzQkntWNMHlDiYQ1qhvwYfxMu5ebPHdN23ds%2F5z6qaEoFONggP0J9oOTAKRIMaXR1s%2FfL4rNVqYSpxkW%2BiZFgKtDwYoFMXZK%2FvoJ776deTDJtGWBlBjkce%2BAcmsIeGaba2v4OoYWes%2Bv6L%2BJsiUHc6FNAiTCBqOzmkJJMTXsXz2u%2BdkwmINaNGwcVysfsB6WBLT%2FRe7fdP5TR44hEY6woFWIZX1mfpyVR5SPkinCrmSScg65Y6XVU%2FSndRylBA6T%2FSHUyznLUF6yHTJtjSeb0AtBf%2Fa6vfod7u4J3OaE5KkFSpZ6XY654n9RZtOf8iemW5a5AN0uJoglVOET%2BuUoR3eGT%2FX%2BqDtFhSpRs6Iw9YrCygY6pgFLvt1ItNuA7jt9LPCIAJAWnx8CSm6LvdBBACxDGM8lK%2Ft0Lu4JA%2FsX8E1SYUyz2mSuz%2BSDseALMsAkTaNYf2tEqhSfjdyKvkCIogEyXib6n4xGJKEImPz2b%2FfN0WWD%2Bl4Hp2seb0aIn4h0a0MolRWHyFyrTBgSy4jroRQSlnZfAP5BJEoVghmAzVDW00OFfAGxXo5AfcF6j9r61BgtWmIe5GvIQiF7&X-Amz-Signature=8168d7a202f539a4aeae1a5078a79d6df1c5d2a2e78d25902e57eb4cd59276c6&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定：顺序栈使用数组，内存连续。链式栈用链表实现，内存不连续


# 可访问性


**只能访问/插入/删除栈顶**


**不能访问中间**


所以要操作某个指定数据，必须先将其上面数据弹出


# 特点（人为规定）

- 后进先出(LIFO):最后压入栈的元素最先被弹出
- 只能在栈顶进行操作:所有的插入和删除操作都在栈顶进行
- 访问受限:不能随机访问栈中的元素

# 分类

- 顺序栈:使用数组实现,容量固定或可动态扩展
- 链式栈:使用链表实现,容量动态变化

## 队列

# 介绍


队列(Queue)是一种先进先出(FIFO, First In First Out)的线性数据结构。它只允许在表的一端进行插入操作,而在另一端进行删除操作。


![1000022963.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/8bc61945-62b1-4908-bda1-1d473e2ac1d3/1000022963.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4664PACBUPT%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041357Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELL%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIBa%2BjYo%2FefDZYw5oFZN6Zh5rt0LUN9K9qrtLB13Z3ag1AiBPC0gQEst9cT0WDP56k3Z9yvQyCqLFfJdjnfrPQyO9DCr%2FAwh6EAAaDDYzNzQyMzE4MzgwNSIMP7C984vodkfNlo9oKtwDrtBCkP2VBRL3hBPObhf1gh1xNfdQN%2BuGp04t50ZFuhDL0IKtMGTX6ZNMRiZ7zdkJrdiOXoYw7UktWVFuU%2BVynMcrM%2F%2F7zmRS%2BXEzu%2FXvfo4rBZdTeLHsQBEmsPwRjqPCJuRxmsfVjqnxJ3U2GYtuO8%2Fp1PE7KPwZjqEC2ruUP%2BgtTj6xUx%2BgYWlx%2BSk%2Brk%2Fa9aGpGWplMIByOuZFpAMQ5aK5Ihs4FS9J04JW60ecb3ZNFOwW%2FR8nIS7N3EJ8fBM0jj8u6XLIRlALbCmKKogszefUz3PmUhzfv35Sam2QJzdyVzAqCR8Vo44twgAboGfuiHRasLEUFpZsrSY2B4f4L2ONp%2FGdrdW5G6fg04KWUbEPcZp2EDLQp8idClrnQ4EjnlRniFgvuQB0J0739KVk8BeKPBYC3deEo7unTVOhDtXr8pGTBdmPd6xbGFe%2FFM9gDmv61OrA%2BUF6kZ1y0nl9WefImkHLsjMxlwIWA4pGN2fj83ce%2F1ktfcJ3PzcQCCtmJuag3jbWQhmSBc1%2BSgdEUj7%2FKtLC0ZuU%2BZwRdcE7kPLQybmc5epMuL8CzP8HeOvMaFw5WiwNk7kDat49riYLiJSQntsHTBWAlGiRNSn7MX4Nd0WWyPd7bp60zvAw%2B4rCygY6pgHNLT8XVUgjejK0W3RblG67HMygFtYOGazN0MZCBqejaT5rflEzlIrB5YRyTXIlw8vobdM5wDPdW56t1IX4HZ%2BGycMVB%2BfNMtDUMyHAR%2BrrOaNUxixEvovXINfU2pp7XDDISClUNBSaOm%2B7mFrtpGzEjLV3xZ%2F2daq7adm45vyOkojAnsGUmB43EOMadt9uFQY5kr00QxWnTaD5bREb6RysmRVr97A5&X-Amz-Signature=a5e8e53af4b473beb6a8b48ffbf917d4c9b99ac5d69ce5f92a3693bafdad038f&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定，顺序队列/循环队列用数组实现，内存连续。链式队列用链表实现，内存不连续。


# 可访问性


**普通队列（链式队列/顺序队列）只能在**


**队头：删除/访问**


**队尾：插入**


双端队列：队头队尾都能插入/访问/删除


**队中间不可访问**


# 特点

1. **先进先出**（FIFO，First In First Out）最先进入队列的元素最先被删除与栈的“后进先出”相对
2. **操作受限：**线性表只允许在队尾插入只允许在队头删除
3. **有两个基本指针：**队头（front）：指向可删除元素队尾（rear）：指向可插入位置
4. **不支持随机访问**：要访问对列中某个数据，要遍历

# 分类

- **顺序队列**:使用**数组实现**的队列,有固定大小
- **链式队列:**使用**链表实现**的队列,大小动态变化
- **循环队列**:用**数组实现**的队列，**顺序队列的改进**,解决"假溢出"问题
- **双端队列**：用**双向链表**或**数组**实现，两端都能删除/插入/访问，但中间依旧不能访问

![1000022964.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/b8af029f-13f0-452e-ac38-c1dc8701168e/1000022964.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4664PACBUPT%2F20251228%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251228T041357Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELL%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIBa%2BjYo%2FefDZYw5oFZN6Zh5rt0LUN9K9qrtLB13Z3ag1AiBPC0gQEst9cT0WDP56k3Z9yvQyCqLFfJdjnfrPQyO9DCr%2FAwh6EAAaDDYzNzQyMzE4MzgwNSIMP7C984vodkfNlo9oKtwDrtBCkP2VBRL3hBPObhf1gh1xNfdQN%2BuGp04t50ZFuhDL0IKtMGTX6ZNMRiZ7zdkJrdiOXoYw7UktWVFuU%2BVynMcrM%2F%2F7zmRS%2BXEzu%2FXvfo4rBZdTeLHsQBEmsPwRjqPCJuRxmsfVjqnxJ3U2GYtuO8%2Fp1PE7KPwZjqEC2ruUP%2BgtTj6xUx%2BgYWlx%2BSk%2Brk%2Fa9aGpGWplMIByOuZFpAMQ5aK5Ihs4FS9J04JW60ecb3ZNFOwW%2FR8nIS7N3EJ8fBM0jj8u6XLIRlALbCmKKogszefUz3PmUhzfv35Sam2QJzdyVzAqCR8Vo44twgAboGfuiHRasLEUFpZsrSY2B4f4L2ONp%2FGdrdW5G6fg04KWUbEPcZp2EDLQp8idClrnQ4EjnlRniFgvuQB0J0739KVk8BeKPBYC3deEo7unTVOhDtXr8pGTBdmPd6xbGFe%2FFM9gDmv61OrA%2BUF6kZ1y0nl9WefImkHLsjMxlwIWA4pGN2fj83ce%2F1ktfcJ3PzcQCCtmJuag3jbWQhmSBc1%2BSgdEUj7%2FKtLC0ZuU%2BZwRdcE7kPLQybmc5epMuL8CzP8HeOvMaFw5WiwNk7kDat49riYLiJSQntsHTBWAlGiRNSn7MX4Nd0WWyPd7bp60zvAw%2B4rCygY6pgHNLT8XVUgjejK0W3RblG67HMygFtYOGazN0MZCBqejaT5rflEzlIrB5YRyTXIlw8vobdM5wDPdW56t1IX4HZ%2BGycMVB%2BfNMtDUMyHAR%2BrrOaNUxixEvovXINfU2pp7XDDISClUNBSaOm%2B7mFrtpGzEjLV3xZ%2F2daq7adm45vyOkojAnsGUmB43EOMadt9uFQY5kr00QxWnTaD5bREb6RysmRVr97A5&X-Amz-Signature=76477df6eff24e673489bc6235150dada692616f701acd55094c24a64f607b24&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


栈的初始化，进栈，出栈，销毁，读栈顶元素，判空没看


栈在括号匹配中/求值中/递归中的应用，


队列的应用

