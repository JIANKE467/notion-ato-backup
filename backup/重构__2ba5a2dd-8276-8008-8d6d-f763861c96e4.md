
重构分两个部分


1.定义（实现原理）：各种大类要包括分出来的小类。如：线性表要知道下属类别：顺序表和其下属类别：顺序表插入/静态分配

> 注重实现方法，代码用文字描述
> 每个最小页面内用函数分类，一个函数写一块，写出总结：将什么几个功能写成几个个函数？**画一个层级图**

2.实现（实现代码）

> 注重代码，用链接链接到1，写出代码，同样一个函数写一块

```plain text
数据结构
│
├── 一、绪论
│     ├── 数据结构三要素
│     │     ├ 数据的逻辑结构
│     │     ├ 数据的存储结构
│     │     └ 数据的运算
│     ├── 四种逻辑结构
│     │     ├ 集合
│     │     ├ 线性结构
│     │     ├ 树形结构
│     │     └ 图结构
│     └── 常用时间复杂度
│           ├O(1)  
│           ├O(n)
│           ├O(n log n)
│           └O(n²)
│
├── 二、线性表  ★重点
│     ├ 顺序表
│     ├ 链表
│     │     ├ 单链表
│     │     ├ 双链表
│     │     └ 循环链表
│     ├ 基本操作
│     │     ├ 插入（移动/指针）
│     │     ├ 删除
│     │     └ 查找
│     └ 与链表比较（时间/空间/效率）
│
├── 三、栈与队列 ★高频
│     ├ 栈（后进先出）
│     │     ├ 入栈/出栈
│     │     └ 表达式求值
│     ├ 队列（先进先出）
│     └ 循环队列（判空判满）
│
├── 四、串（了解）
│     ├ BF匹配
│     ├ KMP
│     │     └ next数组
│     └ 模式匹配复杂度
│
├── 五、树与二叉树 ★大题区
│     ├ 二叉树概念
│     │     ├ 满
│     │     ├ 完全
│     │     └ 性质
│     ├ 遍历
│     │     ├ 先
│     │     ├ 中
│     │     ├ 后
│     │     └ 层次
│     ├ 二叉排序树
│     └ 平衡树AVL
│
├── 六、图  ★难点
│     ├ 邻接矩阵
│     ├ 邻接表
│     ├ DFS
│     ├ BFS
│     ├ 最小生成树
│     │     ├ Prim
│     │     └ Kruskal
│     └ 最短路径
│           ├ Dijkstra
│           └ Floyd
│
├── 七、查找
│     ├ 顺序查找
│     ├ 折半查找
│     ├ 二叉排序树
│     ├ AVL树
│     ├ 哈希表
│     │     └ 冲突处理：链地址/开放地址
│
└── 八、排序 ★考得最多
      ├ 内部排序
      │   ├ 冒泡
      │   ├ 选择
      │   ├ 插入
      │   ├ 快排
      │   ├ 归并
      │   └ 堆排
      ├ 时间复杂度
      └ 稳定性
```


## 线性表

## 顺序表

# 描述


    顺序表是一种线性数据结构,它使用一组连续的内存空间来存储数据元素。在顺序表中,元素按照逻辑顺序依次存放,每个元素的位置由其下标(索引)确定。这种存储方式使得顺序表可以实现快速的随机访问,时间复杂度为O(1)。


    **顺序表 = 用一段连续的内存顺序存放数据的线性表。**


    ![1000022845.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/4d4c34a1-b22d-4315-be4b-6780d9650784/1000022845.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4665TXX7L5E%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040247Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIAVzoSZ%2FBiqPJ9x49Jkomcn7keu5QahrlSRr0zap8NITAiEAwvkw5Seco5tjRC%2FPO%2BpY0sYJ185YSQNjiW%2BPxUqyEy0qiAQItP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDOsl0jUwqPGsqCyuJSrcA4Gq5085MakAU09gzXHIy10cX3hqk4A6bbMLN5M7bCHiGpm2CK3QNZNTXcI6WGKFz8zHzX%2Bw1dDkfu91lHK7gwUjIFOguG1SOtqw%2BTP1RCQ5J7ZZLl4IDWrmhItDtQnZmJt8x6sryMGPD7eiD5P7MXTis1a8b%2BAgSxPLdtMgLg9gyWX05EZpqXxNuwBEw62qC6c0DdNu5CUVuqxxqOxrHykLC7TRFrUO0Ju0ZPgUR5bzL4a5cXr57O7d%2BV0DIoGKTmtVCPyzjnptrhpij25uam8QTsCERuoMRtUE%2Bz691MLPYRlcJwPFSMsdDPrkpkFVXmCjvPlMBFWSwJ5ac8s9S0N64wJeRqJsNiE6Fz2Alsf7mQC7cnOK95OjshQDDJNBmzq4taLwn4drIGNacPpXnHhv1d%2Fv7vx7mCBcqz2ASsdzhQ40RwtU9uIHtGwYaLxERUe1h8rItpL%2BPecuXUZBEV1jwnRhArRrRr9VB8Yg227sr85GRwcyAwn9E%2Bby6EPKHwgca4%2BhiD0zHfGc0%2BqP2Ufk70N22GsNQVBVtGpa7BUnJ5V%2B%2BFfbZfejgpe9%2Ftx5EEhe4gGmy20SLzHKMCgUJfM5yo6d7tvbH6x0iN%2BV720LoyZqadutnI%2Fg4pWeMKGEh8sGOqUBhnlBMid256CBHC5z9MtNYNzBAWqy5Ut8WmouErLwYcab%2FAH6K%2Fv3CaUzvBgaL%2FUWXruLUPMgBRBkCN9f%2BnL8b5g%2FeIJtO38W1Jg4Msy2E%2F4N7TWRlaC%2BGkXVrat4%2F8CKeFbyhUQl%2FYbuUVDbNVI8Y5iXo7HyRz2t1y6ti7YMIpOR%2FknpYqD3ltvIcFWAec0EFyiq04XZrE5B9hZ2dTZjokqPSy8j&X-Amz-Signature=1dc4a9e3682419d8f15729f638586bbe0d4e66e79a716b3dc432696539f62f65&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


    （以上图为内存结构）


# 内存特点


连续的内存


# 节点结构


只有数据


# 特点

    - **随机访问效率高:**可以通过下标直接访问任意元素,时间复杂度为O(1)
    - **存储密度高:**不需要额外的空间存储元素之间的逻辑关系
    - **插入删除效率低:**在中间位置插入或删除元素时,需要移动其后面大量元素,时间复杂度为O(n)
    - **空间固定:**需要预先分配固定大小的连续内存空间,可能造成空间浪费或溢出
    - **内存连续**

# 顺序表有两类


    ## 静态分配的顺序表


    **用数组实现**，长度固定


    ## 动态分配的顺序表


    **用malloc函数申请内存空间，用指针访问，修改，删除，添加，**长度可扩展


# 适用场景


频繁读取/修改


不经常插入删除（慢）


## 定义+初始化

## 顺序表的实现——静态分配


    使用静态数组（固定大小的数组）叫静态分配


    ### 定义顺序表结构（结构体）


    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #define MAX_SIZE 100 // 定义顺序表大小
    typedef struct {
       int data[MAX_SIZE]; // 用数组存数据
       int length; // 顺序表当前长度
    } SeqList;
    ```


    **速记：**


    **用结构体打包一个数组（存数据），一个变量（存顺序表当前长度）**


    ### 初始化顺序表（函数）

    - 需要将length变量（顺序表长度）赋为0
    - 需要将数组中的每个元素赋值为0（内存中有脏数据）（用一个for循环实现）

    ```c
    void InitList (SeqList){
      for (int i=0; i<MaxSize; i++)
        L.data=0;
      L.length=0;
    }
    ```


    速记：


    这是一个函数，执行：遍历数组并赋0，记录顺序表长度的变量赋0。


    ### 主函数


    ```c
    int main(){
      SeqList L; //声明一个顺序表
      InitList(L); //初始化顺序表
      //...后续操作
      return 0;
    }
    ```


## 单链表

# 描述


单链表由一系列节点组成,每个节点包含数据域和指向下一个节点的指针域。链表中的节点在内存中不必连续存储,通过指针将各个节点串联起来。


![1000022847.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/c32cf9a2-961e-4c2e-8dcb-cb0a1f6f8313/1000022847.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466WVST6RFB%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040248Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIB3OWCvWtdcbJYG4XbLfYAC52Uz7R0bzNz24PlBbOXAXAiEA9HsJwWrLd5JF0QSLP8gKCGdVccIXaemsLK6yGVOxADoqiAQItf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDCJR17jyaWAbO57i3yrcA2PvpuU38Lt5afc4RsousmubDSaNpwC3dC4zumefvo8zXBFEKKSdt%2B0uuEgjsZoaRdoU%2FIJT%2B8W%2F9yO7meucjZyrC3TZkRldHrszpz5NXBj3NyAoYZPottEWp5VMnkFC8ksgZFFS20QSaHBTYFjWSYqUirA3G%2BpS7ndXTcnEm2eExTZqMOnckGVH97SzQW%2FjbIFN9rUYdXUD%2BjwlLpqdJb7QH9i8gmHXLq1JgrJA19l%2FRxCgTiMv4xWYKplSTz%2BpJn7g3KrDHPGmMnCrXqSlfMDOZJAtmRUH0GUc7v%2BQSQ1RME%2BJgP86dxXFVkJsrE%2FGjWvmm0n14%2ByLJjw39xEHP3UKmf7tbtXhSpjaa2oT7KZUJDJrTZB9BxZWcVtqgqrO5cqeScNAChP3uA3GXCGMqVhCoR%2FQQ5Cblv64xGNJAklnyRNf%2FaIi3KyCGbKL%2BBdzvq%2BvmHRehOzT%2FUbV%2FMzU7Px5cngeW0TTa37X5x%2FVgbigF%2FGJq0nRVf3b9Eh%2F9HOYiWDA9ADZKe2CRAzpTwXqlx9rVl6gR9TPvafEa24px25C2NlXx5iPkJOg1Q1As5zPnXNAcmqtuneedC1iIWU1fBgaJpCqC9%2FCDDy9LVAchLZblPzhEBxHWUJeaZXBMMSdh8sGOqUB0r%2FJZ524qESk1QlZx%2BKTz%2FgvMFVjFif%2FynbmnSYBwHvW1VAVRsxUmLVnUUgwkoyT9W27W8Ij%2FKTlh8yrgguKe5Xys99Pj1gDR0AzqeL9l84xjXXDY6mJuLJRzlqt%2BaM66ijuK2g%2B8SR3Gl%2FvWqLfgZj6FRRwk5BU9A5LuuEe1jTtjhUtDfthe%2Fgt6uYFYjjL%2F8AikUg2%2FpGEdmVmRus%2FrPqxi9lj&X-Amz-Signature=fa96f6c5d24157c729071d8d27d45a19c47284f28606a3953917f5b16ca76dde&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


（以上图为内存结构）


# 内存特点


不连续的内存


# 节点结构


数据+下一个节点的指针


# 特点

- **无需连续内存**: 链表的大小可以动态调整,无需预先分配固定的内存空间
- **插入删除高效**: 插入删除只需要修改指针
- **访问效率低**: 不支持随机访问,查找特定元素需要从头节点开始遍历,时间复杂度为O(n)
- 只能单向查找

# 分类


### 按有无头节点分：


**带头节点的单链表**


带头节点的单链表在链表的开始位置增加了一个不存储有效数据的头节点,头节点的指针域指向第一个实际存储数据的节点。


**好处**：

- 第一个节点不需要特殊处理

**不带头结点的单链表**


不带头节点的单链表直接从第一个存储有效数据的节点开始,没有额外的头节点。


**坏处**：

- 修改第一个节点需要修改整个链表的指针（整个链表的指针就是指向第一个节点的指针）

### 按循环与否分：


**循环单链表**


循环单链表的最后一个节点的指针域不指向NULL,而是指向头节点(或第一个节点),形成一个环形结构。这样可以从任意节点出发遍历整个链表。


**非循环单链表**


非循环单链表的最后一个节点的指针域指向NULL,表示链表的结束。这是最常见的单链表形式。


## 双链表

# 描述


双链表每个节点包含三个部分:数据域、指向前一个节点的指针和指向后一个节点的指针。与单链表相比,双链表可以双向遍历,既能向前访问也能向后访问。


![1000022959.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/fbd430d3-d204-4691-9d1a-98cb381e5713/1000022959.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46675OGSLJE%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040249Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFmGIn2olAnfdvfkmMKB4lE2Yhjcc7XtfW0nMtzk9H7SAiBSlIk%2FA3ULiwh0O1R2YHbhVrO9tcSRF5c5alNsa4kLECqIBAi1%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDYzNzQyMzE4MzgwNSIMPCYGpt9lrs%2BOBpsLKtwDGE3WKmz21IovkTrr7X4P1w6wvMwOG4Fam5xRKtaR59dbhVwLIV2e%2FFtX80Uu7K1blKfU2RPuBsoFJDmQNlqxao5itDgz%2F3vi05eynd6aJWDNZyiPv4lzlTxOQd7auaLFBEnx%2BWatY%2BgZAzYkQ%2F%2BrQGoTfg0PrL%2BIMEk8UeunP0KzjQHk42hS%2FJF1HYkTxA7Bp%2F5R6ZLDYyFuNV8vsNLC7EYBcdb6EFj9%2FiA2b%2BEX%2BbJmiML8pH%2Fu9Ot6XXialRc7j%2B6IvBUoUtpU3kgaTrYP9MDmIXzt5QiFbZZoI26h2naS4JR8DAESoLSW%2FSJCpZ4ZcS6o3xJ2usfQTLaHri4fwYkWcat5ZHtNxkKru3JtB%2BEk%2BoNPS%2F8AgJaP1WlnrX9P9iTGglvMnfz2ArESj%2Fw%2FrwO6u47C5Jbn2ZAonzmkUzW92LdghcZd37zyuodDH5IWiGIEqZnV9Egl20vvxmZUGWQIv%2FFwcC9kbHZtihZDPXf3qN6v0i4nIfHksFy9YdMTskoEEQspd8FDp8d2uNeHGXYvELgGS4mmDLmeVyCDKuSNsnNSa2fZceRVQEA7ghSNhMQmME5ibXKYxz3ck751Lj8rLw7MhlaVVn9t4lIyk6h615LNopc5vyCSsyAw3p2HywY6pgFogSS%2FW8kezHqqEabRN8%2Bb733%2BX2N3X4okMj0p6VGGPUipHnc6gW4rziBNofws5IsWVmM%2FL9bbDvkjZ8llpoZx8aaITpbScLAJxPS8T1VGU7RFbZ07ezYjkZuHLww526Ot3KJvFW0fg9M4rW5H4pBzSPoaEG%2FX4Tf760o1x7H4aOj%2B%2FOtcz9h8pLnvjITkbQk%2F2%2FPan%2FTYonGhPRonvc%2FWk67o7o4j&X-Amz-Signature=5219cba1ff7c23dc961395e4a55628cd8daa69856a9d5a698141e4765b38f33a&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


不连续的内存


# 节点结构


上一个节点指针 + 数据 + 下一个节点指针


# 特点

- 可以双向遍历,提高了查找效率
- 在已知某个结点的情况下，删除该结点不需要遍历找到其前驱，插入结点时，能直接同时调整前后指针
- 占用更多内存空间,因为每个节点需要两个指针域

# 分类


按循环与否分：

- 循环双链表:首尾相连,头节点的前驱指向尾节点,尾节点的后继指向头节点
- 非循环双链表:头节点的前驱和尾节点的后继均为空指针

按有无头节点分：

- 带头节点的双链表:有一个不存储有效数据的头节点,便于统一处理插入和删除操作
- 不带头节点的双链表:第一个节点即存储有效数据,操作时需要特殊处理边界情况

## 循环链表

# 介绍


循环链表最后一个节点的指针域指向链表的第一个节点,形成一个环形结构。与普通单链表相比,循环单链表没有明确的"结束"标志,可以从任意节点出发遍历整个链表。


![1000022960.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/d2324c7f-99fa-47eb-9d93-3d4cb14ed9f4/1000022960.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4666MNHTHJZ%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQD7TtnFhz%2BxCEfJiR0dM%2F4CX6Rcq5l0LOHujK%2F9AxXlnAIhAJKPhxi3unCK629gLra0v%2BEHPUGAaJYUmEr3Kt14FxBQKogECLX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1IgyOpYKfddVjvdJZnBcq3ANPSHJxe5OvD0Sbq1QkF5zATgHawH7fDtORMA0P%2By8Koa9pJN9ZzOSKPYD3PsBJO2ffYPWS5BzDLFjvd0XYMDzYozXIUZnkEkj%2BF04sgU277VaJkwj1Frw5jlWAfNRoual1zAcTJaLQjVT0tezn3TwEWcuvh9AZR%2BCL7N4%2B11Ac4TAV%2FkcGBKYkO48ZX4CAap%2BtYXePS%2BLeBhMWEbg0SH0sniXpsePNOAZhuR8r2gVC3g1xMd3Kok9U6tfsSv5RSZwaYtbE2Zf4P0huFyOiqo6ov12NgE04eAcQihNx2MxjCABapCkbugZjXOejXbcdKJTqq5PT7mvanINeMcqlZtbj0xiRfrYN13Ld59jgEUpVIR7%2BEJXQfl%2BhQW1UhVFOiAIwh2UX%2By8CIMyA5GS%2F8W9Xr6qd%2BhaUnl%2F0oR%2FuH3PLi%2Fu7jVKMAgyCUU916XwhmW9mOD63t8h3f5GUc02QkTuaVmBrY35tc6AMelPvgm8EmqHxl3%2FYbXAbwAa7844BpI90HRjtuYykaN8Dvkxdp2rH7L5%2BA0p4%2FSlIncI%2B4m8K7K2GXFUH7PNd%2FBjL2vffDR%2BvTeiJi4NmPJQ2mXAlQYRgu4UZ7v7B1qoSt%2BhKeNEKgDVXl9RtQONTmzOrBzDKnYfLBjqkAee5IFfFfIXjJmwj4rIgPQinqYiHXjjOVRW9PKXvS1RSJOTssPn3IKWpfeO%2Bfn1skCVykQ8%2BoSw6z3QgVYd9QQWKzYeWBgDJRZfX4z5oKxZv6Zh55X2LGgouDXd8lT6rl0BDXMutEfyW2pH4H5h6r5mNlly%2B3CqbqI3HXnRHh6SIPMTLsPWzHULUQ2sUB8%2F8CsiPUctF%2BH%2BvSqdFMsCyIdMWf1l9&X-Amz-Signature=596ea7aa463e9b0a41ec5b930f2d050cc4f74e0015e5796721adf03d598a99e2&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定，循环的静态链表是连续内存，循环的单/双链表内存不连续


# 节点结构


视情况而定如果是循环单链表与单链表一致，如果是循环双链表与双链表一致


# 特点

- **无明确尾节点**:最后一个节点指向头节点
- **可从任意节点遍历整个链表**
- **空表和非空表判定方式不同**：空循环链表：头指针为空，或头结点的 next 指向自身（视实现而定）

# 分类


按有无头节点分：


根据是否使用头节点,循环单链表可以分为以下两种实现方式:

- **带头节点的循环单链表**:设置一个不存储数据的头节点,头节点的 next 指向第一个数据节点,最后一个节点的 next 指向头节点
- **不带头节点的循环单链表**:头指针直接指向第一个数据节点,最后一个节点的 next 指向第一个数据节点

按单双链表分：

- **循环单链表**:每个节点只有一个指针域,指向下一个节点,最后一个节点指向第一个节点
- **循环双链表**:每个节点有两个指针域(前驱和后继),可以双向遍历,首尾节点相互连接形成环

## 静态链表

# 介绍


静态链表是用数组来描述的链表结构,它把数组元素分为两个部分:数据域和游标域。数据域用来存储数据元素,游标域用来存储下一个元素的数组下标,从而模拟链表中的指针功能。这种数据结构在一些不支持指针的编程语言中特别有用,同时也便于实现内存的统一管理。


![1000022961.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/6715167f-1db2-46b8-aa67-4cc9c7ef07df/1000022961.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466VMHHFRO6%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCt6eltDveYlu8vD9DLQhDSAOUbxISYqkT6dm2AqI00mwIhAJDAQ8P3lWtROo1oeTSzaYcOZKkk%2Ftke16jShlkmHN2pKogECLX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1IgzWRlxlKPBmY4zTaqkq3AMO4dk%2BQGUXcev2fkanfsQtdM3dFRF3lEqCOJ1zdQZQRJfdTeV4V%2Fbd8RusyjO4iVePNiMQl%2Fqr5M1Sxn6BBxnTMgK018KF6BQl5o%2B5NHV35lJCp%2BI%2B1R1cwzlaz6kgINzNLikBEpZnGSEO6P4IkIchxyCjV2V7xQ4VPkiub1Iy5%2B9POOXzPvyHt5MBRvLTbUXuyNs7LpkxoVeXaFaVTeTxedarTpvLTsai8UKEd0ZOEH9V7k1sFsByNEdLF%2FpDOZgP3jlAxQJW2Mssj%2F34zNIVjRcqfjpTiuWKwAB7kqANrf7UC5zoB0NWBdluYewXNU6zQ%2Fl8hco7zeZP94GAmWo27%2BcZZrCmBZl%2B3FDDATBtsok%2F0sV24aeFnBHHACsbkYNs3SHDYn2E83hDnx7cq7K94trPhs67LIc7sU49D8b%2FCKabUQ5moV6xjSN%2BY7ShbQO5yB%2FtXOP6UOH321KyQ90Dpb0GwgS5UO6VzRQw6BGtMC0rdIDkv0eN4dDRLRFdOkxX4xRllANya74PHmK3ZWkOmFYdQnRTcq%2BVQVs5sTp2e1a9lC1r3TTP2bSyONOn7suMN5Q1igRNKktcjrrV6f0FZvOGetHW3H%2Brxky1bexzgsyi1XJwtWj1fFMB5TDDnYfLBjqkAWxwzt%2FRompQasD3rcgDLFy6aOKAqFv78WyQllsy20dnA17y%2Fu9v%2BuTQG%2BiJ8pOGQiO%2Bh9tm%2Blb3fxV7PkTXO%2F8BPlCiXpVmurR%2B%2F6hFlZ8JsWQ5R1U5Pln74hU9yrf5M%2B%2BLhqUmf6tpXeg5p0i0LvEH0e5fmBKWMEPktFCw9C3JMCJpmCOOlAXl%2FeKSbzPezqpGFAEfiCzXTYccG9a4aVyuBG9n&X-Amz-Signature=c16a6c613ea13a5136f7684f2dd6b852b957d9f3039f11cca0b314bf69c8cde1&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


PS：静态链表与其他链表不同，需要申请连续的内存空间


PS：静态链表与顺序表的区别：


顺序表按顺序存储（直接使用数组），


静态链表虽然使用连续内存空间，但不按顺序存储（用数组+游标模拟指针）


# 内存特点


连续内存


# 节点结构


数据+游标（游标记录了下一个节点的数组下标）


要点：


如：静态链表的游标顺序：2-15613；数组第4个数是头节点


代表按照：数组第四个→第六个→第三个→第五个→第一个→第二个  的顺序访问


PS：**一般规定第一个节点（也就是数组下标为0）的节点为头节点，最后一个节点的游标为-1**


# 特点

- 使用数组实现,需要预先分配固定大小的存储空间
- 通过游标(cur)来模拟指针,实现元素之间的逻辑链接
- 插入和删除操作不需要移动大量元素,只需修改游标值

# 分类


## 按存储方式分类

- 单链静态链表:每个节点只包含一个游标,指向下一个节点
- 双链静态链表:每个节点包含两个游标,分别指向前驱和后继节点

## 按功能分类

- 备用链表:用于管理空闲节点,便于动态分配和回收
- 数据链表:实际存储数据的链表结构

## 按是否循环分

- 循环静态链表:最后一个节点的游标指向头节点,形成环形结构
- 非循环静态链表:最后一个节点的游标为-1,表示链表结束

# 备用链表


使用静态数组：数组申请的空间是固定的，在插入等一系列操作完，会留下剩余未使用空间，将这些空间的下标组成一个静态链表，当需要插入一个节点时可以直接通过备用链表找到空闲位置


PS：没有备用链表就只能遍历


没看：


初始化，销毁，插入，删除，按值查找，按位查找


求表长，输出操作，判空


## 栈与队列

## 栈

# 介绍


栈(Stack)是一种遵循后进先出(LIFO, Last In First Out)原则的线性数据结构。它就像一摞盘子,只能从顶部添加或移除元素。


只允许在一端插入/删除/修改


![1000022962.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/f159f114-04b2-4fa4-b54e-096d4e1300d6/1000022962.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466ZAEWIR7S%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDOzeky%2BySXepEtF5ozla6h619EosBN6AjE1OZHc942CwIgH4t2DqeUHFgdHSs%2B2yQdWxtlDPCY2MqQ95kVoUsyT8cqiAQItf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDFT0W6WLqmthQv6aYyrcAyPJpCXAH%2BqvZIun09w7WAS6XqHKZZz2qOI5a0iQ0O9HoKBsd8F5%2BKso1BgCooQdVTc3PEfENUjRd1MCXM6F%2FHL%2FJro8M3sxw9bEZoivi8m8SpZa37JjO4eWjsfRMbGSOwzXa6IHIRg%2FLXpX9zCb5R17s8UDL0Ei8J2YjSR8OJRAwGVHaQTz4%2Bkd%2BijwxYnvfm%2FTnqBJGgyez3oSAEUE8OCBi%2BPvNyXo0uPZ9ItsvmDwCGBr5Xyv3G%2FoX5JdH43i92TN3tsqi%2Fxd9sJDpthIT92kHjRK%2BINwCoM4B3Qq2BmQ2FjETY%2FC6lOkGWlxnQICekOBlxqeHpvbQ0w6TWIcBX4ErF1X6s5QgjPKO8TpzO8lwRE1QVjD0gXZjROpDnznmeIHfMB%2BBG0gThvcZ%2Bvg%2FL7zA%2BfQ1D%2Bn2gIAwP0g22TGpcAQcG8HcMyEy6xTjAkUiKi73FGaE%2F4vYop6QVGu9MM7RLAwzUMibQMfRBpavK9%2BeJ%2Fthlqyqeuq%2BColGzWZLqr2gGephhp1xAw9c0dUw%2FFWtUgLNLf5PCNcA74bfGVS2ZQkbtug0VfwuD9%2Fy5Z7mUHIkmQ5qgcpG5O%2BLmoSanO4uqnJkaUR%2Fnn782dpNZLmxoersKvYQxG1TZZiMMWdh8sGOqUB4KK9Y3b57uxxRQ%2BHkwkviFyY3LyCRPmSu2qgwf348IKoRgf15uk%2BR4Tv8LueWQBlHA5g3Syd241V7eyU7cs4n%2BQshIcqGXCFNYwoxjgjXVyWrqMfKB3X91tKhANNw%2BYQd4xe2xA%2Bql5O0H%2Fw1zxjogQaGHHn5zcZuwP2FbF1Bv%2BBIAbBxmwOfkTqqPnJVZ2TNCZ789TqUW%2FVufcnRVkjq95wsEhY&X-Amz-Signature=b3a95c9daee6e4a210a10aeda843cc63ef2056abe3523cd7f0c5d99a2dbad1c8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定：顺序栈使用数组，内存连续。链式栈用链表实现，内存不连续


# 可访问性


**只能访问/插入/删除栈顶**


**不能访问中间**


所以要操作某个指定数据，必须先将其上面数据弹出


# 特点（人为规定）

- 后进先出(LIFO):最后压入栈的元素最先被弹出
- 只能在栈顶进行操作:所有的插入和删除操作都在栈顶进行
- 访问受限:不能随机访问栈中的元素

# 分类

- 顺序栈:使用数组实现,容量固定或可动态扩展
- 链式栈:使用链表实现,容量动态变化

## 队列

# 介绍


队列(Queue)是一种先进先出(FIFO, First In First Out)的线性数据结构。它只允许在表的一端进行插入操作,而在另一端进行删除操作。


![1000022963.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/8bc61945-62b1-4908-bda1-1d473e2ac1d3/1000022963.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466WHCOVF4B%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIC7rX%2F4hkMhQ8NMPaqTn1HhRLI3R27NTuzBSAQcvc146AiEA66fUL4%2BvDHJwkeGMkXd0jLkctaPE4T2t%2F7o7wHDe3iIqiAQItP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDC%2Bkse2AjJHLhdhY4ircA3Rhuj%2F08eVepb%2F3f5qefip%2BmCti5L0zc%2FTM%2B92BCW2UpsyDJPkRY208%2FdTBGcHsMHvsOFw4zQ7%2Be5feICzHLv8T%2F2zFfLTRtiZcLvsvLMv%2Bl5ca5hDDfS9nW8SYhalMG5tvjiiv%2B4Ar93hSUriLxHE24uytfjmR7DbyO2zCim83wKl3HeP4epGflLO8D4JqWzlifhif8D1HM8b8cxh2QvX1NvCAG%2Fu5Oqhos2%2BMGIexCLzduKmDfby2Hry7P5o%2BaAbGvR3JzwgJH3mIju9PvAhOcEsoM7If5W1Bvd%2FsmkqpnFvdSSChSDM1fLl2t5F06K88v4n9vftC7RvaMrKTELl1JMHfATDiCnGGqZs2z7xAMniVlHzB2N4MmGnoj0klK6FLQ2Z9LoGn117rZ2oMlBex1o1nbiV2wpdPd%2FecSPEgzexqFvdQdRHzrQ8fTkWN%2BZk51I8l2k2N3QvFoeVLsuH114X4jPihDu58U27Lp59FYXy5cdudb1hCjP2eBZYdIrZ9TwmkP1tPcSByVIxdLGToNyLiPwvn06%2FHXBMUr5t33v9hCvHecKlWeMzy24QNZOQ2%2FbICOS3ZXBBXpjSe2cy4YPSdxcgKNbKydGCudMLt8bo%2FmGJaqZxFckeYMPSDh8sGOqUBMTOiIWa6EE8xAAiZ8dHrLa%2FRz96qj6UYXaIfIO7vcjrst8JDMfBAbIaOnUmPSSj%2B3a%2FHYcKqLk7PwSYYBvzdWI0xX8kbxwYR4qDtxJ4e6tMf%2FyUDujl9qBsIghAocDxJv6Tyj3c6k8HNvpAjB%2BhOYZiQNXDBmHEIcTSfktl%2FwoDpjx5DLPq4BMoX0YKu3Sqqi9xpxnMnRir2E2i2ixYpaDBR7zTJ&X-Amz-Signature=e4b16d1248f2127693b66a24443ae263ede8af00ae3c4b10dbf272c69f49787e&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


# 内存特点


视情况而定，顺序队列/循环队列用数组实现，内存连续。链式队列用链表实现，内存不连续。


# 可访问性


**普通队列（链式队列/顺序队列）只能在**


**队头：删除/访问**


**队尾：插入**


双端队列：队头队尾都能插入/访问/删除


**队中间不可访问**


# 特点

1. **先进先出**（FIFO，First In First Out）最先进入队列的元素最先被删除与栈的“后进先出”相对
2. **操作受限：**线性表只允许在队尾插入只允许在队头删除
3. **有两个基本指针：**队头（front）：指向可删除元素队尾（rear）：指向可插入位置
4. **不支持随机访问**：要访问对列中某个数据，要遍历

# 分类

- **顺序队列**:使用**数组实现**的队列,有固定大小
- **链式队列:**使用**链表实现**的队列,大小动态变化
- **循环队列**:用**数组实现**的队列，**顺序队列的改进**,解决"假溢出"问题
- **双端队列**：用**双向链表**或**数组**实现，两端都能删除/插入/访问，但中间依旧不能访问

![1000022964.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/b8af029f-13f0-452e-ac38-c1dc8701168e/1000022964.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466WHCOVF4B%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIC7rX%2F4hkMhQ8NMPaqTn1HhRLI3R27NTuzBSAQcvc146AiEA66fUL4%2BvDHJwkeGMkXd0jLkctaPE4T2t%2F7o7wHDe3iIqiAQItP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDC%2Bkse2AjJHLhdhY4ircA3Rhuj%2F08eVepb%2F3f5qefip%2BmCti5L0zc%2FTM%2B92BCW2UpsyDJPkRY208%2FdTBGcHsMHvsOFw4zQ7%2Be5feICzHLv8T%2F2zFfLTRtiZcLvsvLMv%2Bl5ca5hDDfS9nW8SYhalMG5tvjiiv%2B4Ar93hSUriLxHE24uytfjmR7DbyO2zCim83wKl3HeP4epGflLO8D4JqWzlifhif8D1HM8b8cxh2QvX1NvCAG%2Fu5Oqhos2%2BMGIexCLzduKmDfby2Hry7P5o%2BaAbGvR3JzwgJH3mIju9PvAhOcEsoM7If5W1Bvd%2FsmkqpnFvdSSChSDM1fLl2t5F06K88v4n9vftC7RvaMrKTELl1JMHfATDiCnGGqZs2z7xAMniVlHzB2N4MmGnoj0klK6FLQ2Z9LoGn117rZ2oMlBex1o1nbiV2wpdPd%2FecSPEgzexqFvdQdRHzrQ8fTkWN%2BZk51I8l2k2N3QvFoeVLsuH114X4jPihDu58U27Lp59FYXy5cdudb1hCjP2eBZYdIrZ9TwmkP1tPcSByVIxdLGToNyLiPwvn06%2FHXBMUr5t33v9hCvHecKlWeMzy24QNZOQ2%2FbICOS3ZXBBXpjSe2cy4YPSdxcgKNbKydGCudMLt8bo%2FmGJaqZxFckeYMPSDh8sGOqUBMTOiIWa6EE8xAAiZ8dHrLa%2FRz96qj6UYXaIfIO7vcjrst8JDMfBAbIaOnUmPSSj%2B3a%2FHYcKqLk7PwSYYBvzdWI0xX8kbxwYR4qDtxJ4e6tMf%2FyUDujl9qBsIghAocDxJv6Tyj3c6k8HNvpAjB%2BhOYZiQNXDBmHEIcTSfktl%2FwoDpjx5DLPq4BMoX0YKu3Sqqi9xpxnMnRir2E2i2ixYpaDBR7zTJ&X-Amz-Signature=322c8752cbef3df816875ccd0597f50feb01aaca84c0cdd627d32bdd235a60a1&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


注意⚠️：多数人会误会的点：普通队列从头取，但与直觉不同的是，**队列不会自动往前**，会出现假溢出，循环队列解决了这个问题


# 常见问题


队头指针：指示队头的位置


队尾指针：指示队尾的下一个位置


队头队尾指针共用一套编号系统，也就是


判空：队头指针==队尾指针


判满（非循环队列）：队尾指针==队列容量


判满（循环队列）：浪费一个单元


```plain text
(rear + 1) % MaxSize == front
```


%maxsize是为了让前面的结果为正


栈的初始化，进栈，出栈，销毁，读栈顶元素，判空没看


栈在括号匹配中/求值中/递归中的应用，


队列的应用


## 树

# 介绍


树是一种非线性的数据结构，由节点（node）和边（edge）组成，具有层次关系。每个树结构都有一个根节点（root），从根节点出发可以到达树中的任何其他节点。树中除了根节点外，每个节点都有且仅有一个父节点，而每个节点可以有零个或多个子节点。


### 术语解释：


**根节点：**


树的最顶层节点


**边：**


连接两个节点的线段


**叶子节点：**


没有子节点的节点，位于树的最底层。


**子树：**


以某个节点为根的树


**分支节点**（非叶子节点）**：**


至少有一个子节点的节点


**前驱：**


遍历时，按遍历顺序，某节点的上一个节点


**后继：**


遍历时，按遍历顺序，某节点的下一个节点


**父节点：**


某节点的上级节点（不是遍历那个）


**孩子节点：**


某节点的下级节点（不是遍历那个）


**兄弟节点：**


具有相同父节点的节点


**堂兄弟节点：**


父节点不同，但在同一层级的节点


**祖先节点：**


从根节点到该节点路径上的所有节点（不包括该节点本身）


**子孙节点：**


某节点的所有子节点和其下属的所有节点


**节点的层次（深度）：**


从根节点到该节点的路径长度，根节点的层次为0或1（根据定义不同）（从上往下数）


**节点的高度：**


从下往上数


**节点的度：**


一个节点下的子节点数量


**树的高度（深度）：**


树中节点的最大层次数


**树的度：**


各节点度的最大值


**路径长度：**


经过几条边


**路径：**


从跟节点到某节点的路径


**有序树：**


树的子树顺序不能交换


**无序树：**


树的子树顺序可以交换


**森林：**


多个互不相交的树的集合，允许空森林


**注意⚠️**


**前驱：除了根结点外每个结点都有且只有一个前驱（否则就不是树结构）**


**空树：根结点下没有一个节点就是空树**


**子树：子树之间要求互不相交**


**路径：单向的只能从上往下**


# 树的常考性质


节点的总数=节点的总度数+1


### N度的树 vs N叉树


| N度的树       | N叉树       |
| ---------- | --------- |
| 至少有一个n度的节点 | 所以节点最多有n度 |
| 一定是非空树     | 可以是空树     |


## 二叉树

二叉树是有序树（左右顺序不能颠倒）


# 二叉树的存储结构


    ## 顺序存储（用下标标记每个节点，从上到下，从左到右，从0开始，节点内不记录下标）


        ### 满二叉树


        二叉树的每一层都长满了节点


        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/4d418c64-80f4-42c4-a227-5fe535bf11d3/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466YK5QISOZ%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040255Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCInmkM4MZ98JFT6D%2FMNBXkPVYINO8Fe6PBgOKhG7dfagIhALrORPEugelKV8PkXTIJooOUFDSgYGewTGs5z2IUZBvKKogECLX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1Igxl9DDNI9o5w6Lg0jAq3ANHkX54ge4wpklZfcaD8j%2F9ferkyOtTcTV3IsXwf4U0n6MmEoziNS8AY4XFSVYadejOvG1KHmRhxxGhr%2FCkV18Q0C%2Fqe1jKNY86pB%2BhpLKo%2BevNyaX5jikjtSopBg%2FskDX6SNAAgd39CQbXm6i4DXuRrSvguhlUaRO%2FoHxGFQPOEqymGT16jZmuNP1K1KixNNcfTEOkCv10V2mIAEV4vJaz02Kukn0rQ2DDZkh4yTLEMveuvlCb%2FsJdPz9ic0NsCU9wyuVM6BZCaj8ta%2BzerE2rMBh7g16ECZJavuZgEpxKzrsb5PDtBbZtsvgc1Gjd3TY10Wp7MwexkldJB7QIxypLdFvJQjEj3se%2FbgQDxueKhxVEyc4nVdjWON79%2BCNIgCCN%2FVuhHStzJwg6KnL8HGh2RwUBMRP9I1pZAiYx8fTw%2BqqWrY8BXMrI14Y%2BEdAV%2FTQc3pt%2F%2F4mYVQtYyUqSPk082K9yj%2FowCv4tOyGc%2F941An7Iun1qvYf1RZIWokH%2BmZpAJxRA0i2QJejRk2e7K8tNscill1%2F43LQOgJmWDy%2BO5Yytvm3rSqrZwltuaAwGZaCU8XsmQOPlRcdfU16eKABj%2FmTPHX7uwAlt2k1motMyx%2FuI2F%2FDCB%2BBzCBvNzCinYfLBjqkAVf0h69v0tqUh%2FSRDMp4iHNIjfvXEU4UhyH%2FecwPGQF7dWZhfOFw6Ukluu0HUe8VJQDe93WxTA3v1jOUWc3kTUMA73dtea7Q%2BsqvCC%2FfSFx1OGMy74w5aVLsP0%2FYDakm2AmtUw2ZjscgIem4zp1onSvni6QozeggV9UQnagJODklIL1Hm1s3DzTqLz9TVjZZrcpM6aOBp8SWz00OwuUhjXbk%2FHYl&X-Amz-Signature=85ab8ed34bcff7226ad6b8a47f157b74473a074446250a759d3f23cd64aacfb8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


        特点：

        - 叶子节点都在最后一层
        - 不存在度为1的节点
        - 按层序从1开始编号，节点 i 的左孩子为 2i 右孩子为 2i+1 ，节点i的父节点为 i/2（如果有的话）

        ### 完全二叉树


        完全二叉树就是满二叉树去掉一部分（去掉某个编号的节点，其后面编号的节点也要去掉）


        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/d0d162f1-36a5-4bc6-8114-ba208efe55cc/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466YK5QISOZ%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040255Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCInmkM4MZ98JFT6D%2FMNBXkPVYINO8Fe6PBgOKhG7dfagIhALrORPEugelKV8PkXTIJooOUFDSgYGewTGs5z2IUZBvKKogECLX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1Igxl9DDNI9o5w6Lg0jAq3ANHkX54ge4wpklZfcaD8j%2F9ferkyOtTcTV3IsXwf4U0n6MmEoziNS8AY4XFSVYadejOvG1KHmRhxxGhr%2FCkV18Q0C%2Fqe1jKNY86pB%2BhpLKo%2BevNyaX5jikjtSopBg%2FskDX6SNAAgd39CQbXm6i4DXuRrSvguhlUaRO%2FoHxGFQPOEqymGT16jZmuNP1K1KixNNcfTEOkCv10V2mIAEV4vJaz02Kukn0rQ2DDZkh4yTLEMveuvlCb%2FsJdPz9ic0NsCU9wyuVM6BZCaj8ta%2BzerE2rMBh7g16ECZJavuZgEpxKzrsb5PDtBbZtsvgc1Gjd3TY10Wp7MwexkldJB7QIxypLdFvJQjEj3se%2FbgQDxueKhxVEyc4nVdjWON79%2BCNIgCCN%2FVuhHStzJwg6KnL8HGh2RwUBMRP9I1pZAiYx8fTw%2BqqWrY8BXMrI14Y%2BEdAV%2FTQc3pt%2F%2F4mYVQtYyUqSPk082K9yj%2FowCv4tOyGc%2F941An7Iun1qvYf1RZIWokH%2BmZpAJxRA0i2QJejRk2e7K8tNscill1%2F43LQOgJmWDy%2BO5Yytvm3rSqrZwltuaAwGZaCU8XsmQOPlRcdfU16eKABj%2FmTPHX7uwAlt2k1motMyx%2FuI2F%2FDCB%2BBzCBvNzCinYfLBjqkAVf0h69v0tqUh%2FSRDMp4iHNIjfvXEU4UhyH%2FecwPGQF7dWZhfOFw6Ukluu0HUe8VJQDe93WxTA3v1jOUWc3kTUMA73dtea7Q%2BsqvCC%2FfSFx1OGMy74w5aVLsP0%2FYDakm2AmtUw2ZjscgIem4zp1onSvni6QozeggV9UQnagJODklIL1Hm1s3DzTqLz9TVjZZrcpM6aOBp8SWz00OwuUhjXbk%2FHYl&X-Amz-Signature=3a1582008227e7b9236b75cc87c963308257a43aa5b83427080c9e3dd47b4e9b&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


        特点：

        - 只有最后两层可能有叶子节点
        - 最多只有一个度为1的节点
        - 按层序从1开始编号，节点 i 的左孩子为 2i 右孩子为 2i+1 ，节点i的父节点为 i/2（如果有的话）（与满二叉树一致）
        - 节点编号 ≤ n/2 的是分支节点，节点编号 > n/2 的是叶子节点

        **PS：如果完全二叉树某节点只有一个孩子，那一定是左孩子**


        ### 二叉排序树


        左子树的所有节点都比根节点小（左小）


        右子树的所有节点都比根节点大（右大）


        左子树和右子树又是一棵二叉排序树（分支也遵守）


        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/3e628423-c889-4b48-8841-21e070e343b9/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466YK5QISOZ%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040255Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCInmkM4MZ98JFT6D%2FMNBXkPVYINO8Fe6PBgOKhG7dfagIhALrORPEugelKV8PkXTIJooOUFDSgYGewTGs5z2IUZBvKKogECLX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1Igxl9DDNI9o5w6Lg0jAq3ANHkX54ge4wpklZfcaD8j%2F9ferkyOtTcTV3IsXwf4U0n6MmEoziNS8AY4XFSVYadejOvG1KHmRhxxGhr%2FCkV18Q0C%2Fqe1jKNY86pB%2BhpLKo%2BevNyaX5jikjtSopBg%2FskDX6SNAAgd39CQbXm6i4DXuRrSvguhlUaRO%2FoHxGFQPOEqymGT16jZmuNP1K1KixNNcfTEOkCv10V2mIAEV4vJaz02Kukn0rQ2DDZkh4yTLEMveuvlCb%2FsJdPz9ic0NsCU9wyuVM6BZCaj8ta%2BzerE2rMBh7g16ECZJavuZgEpxKzrsb5PDtBbZtsvgc1Gjd3TY10Wp7MwexkldJB7QIxypLdFvJQjEj3se%2FbgQDxueKhxVEyc4nVdjWON79%2BCNIgCCN%2FVuhHStzJwg6KnL8HGh2RwUBMRP9I1pZAiYx8fTw%2BqqWrY8BXMrI14Y%2BEdAV%2FTQc3pt%2F%2F4mYVQtYyUqSPk082K9yj%2FowCv4tOyGc%2F941An7Iun1qvYf1RZIWokH%2BmZpAJxRA0i2QJejRk2e7K8tNscill1%2F43LQOgJmWDy%2BO5Yytvm3rSqrZwltuaAwGZaCU8XsmQOPlRcdfU16eKABj%2FmTPHX7uwAlt2k1motMyx%2FuI2F%2FDCB%2BBzCBvNzCinYfLBjqkAVf0h69v0tqUh%2FSRDMp4iHNIjfvXEU4UhyH%2FecwPGQF7dWZhfOFw6Ukluu0HUe8VJQDe93WxTA3v1jOUWc3kTUMA73dtea7Q%2BsqvCC%2FfSFx1OGMy74w5aVLsP0%2FYDakm2AmtUw2ZjscgIem4zp1onSvni6QozeggV9UQnagJODklIL1Hm1s3DzTqLz9TVjZZrcpM6aOBp8SWz00OwuUhjXbk%2FHYl&X-Amz-Signature=b23060e4027da2cd209f3cc495a50e489ffdda284224f0a83e3d549aeaf24e4b&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


        ### 平衡二叉树


        树上任一左子树和右子树深度之差不超过1


        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51145155-d0f0-4bb1-85cf-344e4c2400e0/c5c2ded4-f51d-4a63-8c25-08688910725d/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466YK5QISOZ%2F20260110%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260110T040255Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEOz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCInmkM4MZ98JFT6D%2FMNBXkPVYINO8Fe6PBgOKhG7dfagIhALrORPEugelKV8PkXTIJooOUFDSgYGewTGs5z2IUZBvKKogECLX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1Igxl9DDNI9o5w6Lg0jAq3ANHkX54ge4wpklZfcaD8j%2F9ferkyOtTcTV3IsXwf4U0n6MmEoziNS8AY4XFSVYadejOvG1KHmRhxxGhr%2FCkV18Q0C%2Fqe1jKNY86pB%2BhpLKo%2BevNyaX5jikjtSopBg%2FskDX6SNAAgd39CQbXm6i4DXuRrSvguhlUaRO%2FoHxGFQPOEqymGT16jZmuNP1K1KixNNcfTEOkCv10V2mIAEV4vJaz02Kukn0rQ2DDZkh4yTLEMveuvlCb%2FsJdPz9ic0NsCU9wyuVM6BZCaj8ta%2BzerE2rMBh7g16ECZJavuZgEpxKzrsb5PDtBbZtsvgc1Gjd3TY10Wp7MwexkldJB7QIxypLdFvJQjEj3se%2FbgQDxueKhxVEyc4nVdjWON79%2BCNIgCCN%2FVuhHStzJwg6KnL8HGh2RwUBMRP9I1pZAiYx8fTw%2BqqWrY8BXMrI14Y%2BEdAV%2FTQc3pt%2F%2F4mYVQtYyUqSPk082K9yj%2FowCv4tOyGc%2F941An7Iun1qvYf1RZIWokH%2BmZpAJxRA0i2QJejRk2e7K8tNscill1%2F43LQOgJmWDy%2BO5Yytvm3rSqrZwltuaAwGZaCU8XsmQOPlRcdfU16eKABj%2FmTPHX7uwAlt2k1motMyx%2FuI2F%2FDCB%2BBzCBvNzCinYfLBjqkAVf0h69v0tqUh%2FSRDMp4iHNIjfvXEU4UhyH%2FecwPGQF7dWZhfOFw6Ukluu0HUe8VJQDe93WxTA3v1jOUWc3kTUMA73dtea7Q%2BsqvCC%2FfSFx1OGMy74w5aVLsP0%2FYDakm2AmtUw2ZjscgIem4zp1onSvni6QozeggV9UQnagJODklIL1Hm1s3DzTqLz9TVjZZrcpM6aOBp8SWz00OwuUhjXbk%2FHYl&X-Amz-Signature=17382eb94dca720a9aa5362fa6b057085332b95d6a58fc29e446cab91e5c83d2&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


        PS：二叉平衡树避免了一边长一边短导致的某些数据搜索缓慢，某些又很快


    ## 链式存储（用指针表示节点间关系，一个节点分三个域，左孩子指针，数据域，右孩子指针）


# 树的逻辑表示


    用广义表表示，规则如下：


    ```plain text
    根节点（一层节点1（二层1，二层2），一层节点2（二层3，二层4））
    ```


    PS：二层的节点1，2 是一层节点1的子节点


    注意⚠️：括号表示法与广义表表示法相似，但括号表示法只能表示二叉树，且同一层顺序不能变


# 树的遍历


    4种方法


    深度优先↓


    **先序遍历**：根左右（从上开始，有根先看根，根没了在看左，左没了在看右）


    （先记根，根记了再记左，左记了再记右）


    **中序遍历**：左根右（从左下开始，有左先看左，左没了在看根，根没了在看右）


    （先不记根，先记左，记完左再记上一级的跟，再记右）


    **后序遍历**：左右根（从左下开始，有左先看左，左没了看右，右没了看根）


    （先不记根，先记左，左记完在记右，右记完再记根）


    广度优先↓


    **层序**：从上到下，从左到右，按层输出


    **第一个括号的解释：“看”就是记录，看左/右都是看的下一层的左右**


    **第二个括号的解释：只要还有子节点，那这个节点就是根**


    前三种记录顺序：先深后广，最后一种顺序：先广后深


# 线索二叉树


    是二叉树的改造，用于解决遍历到叶子节点时还要大量处理才能回到上一根节点的问题


    **它在节点中添加了两个域↓**


    **左标记域** | 左指针 | 数据域 | 右指针 |**右标记域**


    **用来指示左/右指针是线索指针还是孩子指针**


    **线索指针指向哪里取决于线索化时采用的遍历方法，指向该遍历方法的上和下一个节点**


# 树的三种存储结构（注意是树，不是上面的二叉树）


    双亲表示法：用数组存储，每个节点两个域：数据域+父节点下标


    孩子表示法：用数组存储，每个节点两个域：数据域+该节点的孩子节点指针链表（不包含孙子节点）


    孩子兄弟表示法：每个节点分三个域：数据域+第一个孩子指针（从左到右）+下一个兄弟指针（该节点的兄弟，从左到右）


# 树/森林转化成二叉树


    ### 树转化为二叉树（仅限于孩子兄弟表示法存储的树）


    第一个孩子节点=左孩子节点


    下一个兄弟节点=右孩子节点


    ### 森林转化成二叉树


    将第一个根节点作为根节点，其他根节点作为第一个根的兄弟节点


    第一个孩子节点=左孩子节点


    下一个兄弟节点=右孩子节点


    ### 反过来转化只需将等号左右对调


    略


# 树/森林的遍历


    深度优先↓


    先根遍历：


    从根开始，将根记录下来，然后记录第一个子树，第一个子树记录完再记录第二个


    后根遍历：


    从根开始，先不记录根，记录完该分支最深的叶子节点在返回记录上一层的根


    广度优先↓


    层次遍历：从上到下，从左到右，按层输出


    森林遍历的前两种就是分别给每个树做先/后根遍历


    层次遍历：不能分别做，把所有树当一个树处理


# 哈夫曼树


    哈夫曼树是一个压缩算法，数据存储在叶子节点中，其他分支称为内部节点


    ### 哈夫曼树的构造

    1. 得到带有权的值
    2. 将权最小的两个节点合并成一个新节点（权相加，值放一起）（贪心算法）
    3. 从剩下的节点和合成的节点中再选出最小的，合并……直到只剩一个树

    PS：**注意是从下往上构造的**


    ### 哈夫曼编码


    哈夫曼编码是一种前缀编码，通过哈夫曼树来实现数据的无损压缩。


    编码规则：从根节点到每个叶子节点的路径上**，****左分支标记为0，右分支标记为1**，路径上的0和1序列就是该叶子节点的编码。


    **ps：出现频率高的字符编码短，出现频率低的字符编码长，从而实现整体编码长度最短**。


    ### 带权路径长度


    这是用来评价压缩率的


    计算方法：


    $$
    WPL=∑(叶子节点的权×该节点到根节点的路径长度)
    $$


    求和是求所有节点的和


    ### 扩充二叉树


    扩充二叉树是在普通二叉树的基础上，为每个**空节点**（没有左孩子或右孩子的节点）添加一个**虚拟节点**，这样每个节点都具有两个子节点。通过这种方式，扩充二叉树将所有的“空节点”显式地表示出来。哈夫曼树是最优的扩充二叉树
    
    


# 堆


    以完全二叉树的顺序存储结构来存储的一种特殊的二叉树。

    - **大根堆**：每个结点的值都大于或等于其左右子结点的值。
    - **小根堆**：每个结点的值都小于或等于其左右子结点的值。
